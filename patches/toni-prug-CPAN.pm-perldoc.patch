--- CPAN.pm	2003-09-20 11:04:16.000000000 +0100
+++ CPAN-perldoc.pm	2004-11-01 11:51:53.000000000 +0000
@@ -54,19 +54,22 @@
 $CPAN::Signal ||= 0;
 $CPAN::Frontend ||= "CPAN::Shell";
 $CPAN::Defaultsite ||= "ftp://ftp.perl.org/pub/CPAN";
+$CPAN::Defaultdocs ||= "http://search.cpan.org/perldoc?";
+$CPAN::Defaultrecent ||= "http://search.cpan.org/recent";
 
 package CPAN;
 use strict qw(vars);
 
 use vars qw($VERSION @EXPORT $AUTOLOAD $DEBUG $META $HAS_USABLE $term
             $Revision $Signal $End $Suppress_readline $Frontend
-            $Defaultsite $Have_warned);
+            $Defaultsite $Have_warned $Defaultdocs $Defaultrecent);
 
 @CPAN::ISA = qw(CPAN::Debug Exporter);
 
 @EXPORT = qw(
 	     autobundle bundle expand force get cvs_import
 	     install make readme recompile shell test clean
+             perldoc recent
 	    );
 
 #-> sub CPAN::AUTOLOAD ;
@@ -256,7 +259,7 @@
 @CPAN::Complete::COMMANDS = sort qw(
 		       ! a b d h i m o q r u autobundle clean dump
 		       make test install force readme reload look
-                       cvs_import ls
+                       cvs_import ls perldoc recent
 ) unless @CPAN::Complete::COMMANDS;
 
 package CPAN::Index;
@@ -1361,6 +1364,7 @@
  i        WORD or /REGEXP/  about anything of above
  r        NONE              reinstall recommendations
  ls       AUTHOR            about files in the author's directory
+ recent   NONE              latest CPAN uploads
 
 Download, Test, Make, Install...
  get                        download
@@ -1370,6 +1374,7 @@
  clean                      make clean
  look                       open subshell in these dists' directories
  readme                     display these dists' README files
+ perldoc                    display module's POD documentation
 
 Other
  h,?           display this menu       ! perl-code   eval a perl command
@@ -2149,6 +2154,14 @@
     }
 }
 
+#-> sub CPAN::Shell::recent ;
+sub recent {
+  my($self) = @_;
+
+  CPAN::Distribution::_display_url( $self, $CPAN::Defaultrecent );
+  return;
+}
+
 #-> sub CPAN::Shell::dump ;
 sub dump    { shift->rematein('dump',@_); }
 #-> sub CPAN::Shell::force ;
@@ -2169,6 +2182,8 @@
 sub look   { shift->rematein('look',@_); }
 #-> sub CPAN::Shell::cvs_import ;
 sub cvs_import   { shift->rematein('cvs_import',@_); }
+#-> sub CPAN::Shell::perldoc ;
+sub perldoc  { shift->rematein('perldoc',@_); }
 
 package CPAN::LWP::UserAgent;
 
@@ -2985,7 +3000,7 @@
     } elsif ($line =~ /^d\s/) {
 	@return = cplx('CPAN::Distribution',$word);
     } elsif ($line =~ m/^(
-                          [mru]|make|clean|dump|get|test|install|readme|look|cvs_import
+                          [mru]|make|clean|dump|get|test|install|readme|look|cvs_import|perldoc|recent
                          )\s/x ) {
         if ($word =~ /^Bundle::/) {
             CPAN::Shell->local_bundles;
@@ -4204,6 +4219,7 @@
 });
     sleep 2;
     $fh_pager->print(<$fh_readme>);
+    $fh_pager->close;
 }
 
 #-> sub CPAN::Distribution::verifyMD5 ;
@@ -4878,6 +4894,181 @@
     shift->{'build_dir'};
 }
 
+#-> sub CPAN::Distribution::perldoc ;
+sub perldoc {
+    my($self) = @_;
+
+    my($dist) = $self->id;
+    my $package = $self->called_for;
+
+    $self->_display_url( $CPAN::Defaultdocs . $package );
+}
+
+#-> sub CPAN::Distribution::_check_binary ;
+sub _check_binary {
+    my ($dist,$shell,$binary) = @_;
+    my ($pid,$readme,$out);
+
+    $CPAN::Frontend->myprint(qq{ + _check_binary($binary)\n})
+      if $CPAN::DEBUG;
+
+    $pid = open $readme, "-|", "which", $binary
+      or $CPAN::Frontend->mydie(qq{Could not fork $binary: $!});
+    while (<$readme>) {
+	$out .= $_;
+    }
+    close $readme;
+
+    $CPAN::Frontend->myprint(qq{   + $out \n})
+      if $CPAN::DEBUG && $out;
+
+    return $out;
+}
+
+#-> sub CPAN::Distribution::_display_url ;
+sub _display_url {
+    my($self,$url) = @_;
+    my($res,$saved_file,$pid,$readme,$out);
+
+    $CPAN::Frontend->myprint(qq{ + _display_url($url)\n})
+      if $CPAN::DEBUG;
+
+    # should we define it in the config instead?
+    my $html_converter = "html2text";
+
+    my $web_browser = $CPAN::Config->{'lynx'} || undef;
+    my $web_browser_out = $web_browser
+      ? CPAN::Distribution->_check_binary($self,$web_browser)
+	: undef;
+
+    my ($tmpout,$tmperr);
+    if (not $web_browser_out) {
+        # web browser not found, let's try text only
+	my $html_converter_out =
+	  CPAN::Distribution->_check_binary($self,$html_converter);
+
+        if ($html_converter_out ) {
+            # html2text found, run it
+            $saved_file = CPAN::Distribution->_getsave_url( $self, $url );
+            $CPAN::Frontend->myprint(qq{ERROR: problems while getting $url, $!\n})
+              unless defined($saved_file);
+
+	    $pid = open $readme, "-|", $html_converter, $saved_file
+	      or $CPAN::Frontend->mydie(qq{
+Could not fork $html_converter $saved_file: $!});
+	    my $fh = FileHandle->new;
+	    my $tmpdir = File::Spec->tmpdir();
+	    my $tmpin  = File::Spec->catfile( $tmpdir,
+					      "cpan__htmlconvert_out.txt" );
+	    if ($fh->open(">$tmpin")) {
+		while (<$readme>) {
+		    $fh->print($_);
+		}
+	    } else {
+		$CPAN::Frontend->mydie(qq{Could not open $tmpin $!});
+	    }
+
+	    close $readme
+	      or $CPAN::Frontend->mydie(qq{Could not close file handle: $!});
+	    $CPAN::Frontend->myprint(qq{
+Run '$html_converter $saved_file' and
+saved output to $tmpin\n})
+              if $CPAN::DEBUG;
+            my $fh_readme = FileHandle->new;
+	    $fh_readme->open($tmpin)
+	      or $CPAN::Frontend->mydie(qq{Could not open "$tmpin": $!});
+            my $fh_pager = FileHandle->new;
+            local($SIG{PIPE}) = "IGNORE";
+            $fh_pager->open("|$CPAN::Config->{'pager'}")
+              or $CPAN::Frontend->mydie(qq{
+Could not open pager $CPAN::Config->{'pager'}: $!});
+	    $CPAN::Frontend->myprint(qq{
+Displaying URL
+  $url
+with pager "$CPAN::Config->{'pager'}"
+});
+	    sleep 2;
+            $fh_pager->print(<$fh_readme>);
+	    $fh_pager->close;
+        } else {
+            # coldn't find the web browser or html converter
+            $CPAN::Frontend->myprint(qq{
+You need to install lynx or $html_converter to use this feature.});
+        }
+    } else {
+        # web browser found, run the action
+	my $browser = $CPAN::Config->{'lynx'};
+        $CPAN::Frontend->myprint(qq{system[$browser $url]})
+	  if $CPAN::DEBUG;
+	$CPAN::Frontend->myprint(qq{
+Displaying URL
+  $url
+with browser $browser
+});
+	sleep 2;
+        system("$browser $url");
+	if ($saved_file) { 1 while unlink($saved_file) }
+    }
+}
+
+#-> sub CPAN::Distribution::_getsave_url ;
+sub _getsave_url {
+    my($dist, $shell, $url) = @_;
+
+    $CPAN::Frontend->myprint(qq{ + _getsave_url($url)\n})
+      if $CPAN::DEBUG;
+
+    my $tmpdir = File::Spec->tmpdir();
+    my $tmpin  = File::Spec->catfile( $tmpdir, "cpan__getsave_url.html" );
+
+    if ($CPAN::META->has_usable('LWP')) {
+        $CPAN::Frontend->myprint("Fetching with LWP:
+  $url
+");
+        my $Ua;
+        CPAN::LWP::UserAgent->config;
+	eval { $Ua = CPAN::LWP::UserAgent->new; };
+	if ($@) {
+	    $CPAN::Frontend->mywarn("ERROR: CPAN::LWP::UserAgent->new dies with $@\n");
+	    return;
+	} else {
+	    my($var);
+	    $Ua->proxy('http', $var)
+	      if $var = $CPAN::Config->{http_proxy} || $ENV{http_proxy};
+	    $Ua->no_proxy($var)
+	      if $var = $CPAN::Config->{no_proxy} || $ENV{no_proxy};
+	}
+
+        my $req = HTTP::Request->new(GET => $url);
+        $req->header('Accept' => 'text/html');
+        my $res = $Ua->request($req);
+          if ($res->is_success) {
+              $CPAN::Frontend->myprint(" + request sucesuful.\n")
+                if $CPAN::DEBUG;
+              my $fh = FileHandle->new;
+	    if ($fh->open(">$tmpin")) {
+		print $fh $res->content;
+		close $fh;
+		$CPAN::Frontend->myprint(qq{ + saved content to $tmpin \n})
+		  if $CPAN::DEBUG;
+		return $tmpin;
+	    } else {
+              $CPAN::Frontend->myprint(qq{ + Could not open $tmpin: $! \n});
+	    }
+          } else {
+              $CPAN::Frontend->myprint(sprintf(
+                                             "LWP failed with code[%s], message[%s]\n",
+                                             $res->code,
+                                             $res->message,
+                                            ));
+              return;
+        }
+    } else {
+        $CPAN::Frontend->myprint("LWP not available\n");
+        return;
+    }
+}
+
 package CPAN::Bundle;
 
 sub look {
@@ -5498,6 +5689,8 @@
     delete $self->{'force_update'};
 }
 
+#-> sub CPAN::Module::perldoc ;
+sub perldoc { shift->rematein('perldoc') }
 #-> sub CPAN::Module::readme ;
 sub readme { shift->rematein('readme') }
 #-> sub CPAN::Module::look ;
@@ -6136,12 +6329,14 @@
 
 being executed within the distribution file's working directory.
 
-=item get, readme, look module or distribution
+=item get, readme, ,perldoc, look module or distribution
 
 C<get> downloads a distribution file without further action. C<readme>
 displays the README file of the associated distribution. C<Look> gets
 and untars (if not yet done) the distribution file, changes to the
 appropriate directory and opens a subshell process in that directory.
+C<perldoc> displays the pod documentation of the module in html or
+plain text format.
 
 =item ls author
 
@@ -6508,6 +6703,15 @@
 Downloads the README file associated with a distribution and runs it
 through the pager specified in C<$CPAN::Config->{pager}>.
 
+=item CPAN::Distribution::perldoc()
+
+Downloads the pod documentation of the file associated with a
+distribution (in html format) and runs it through the external
+command lynx specified in C<$CPAN::Config->{lynx}>. If lynx
+isn't available, it converts it to plain text with external
+command html2text and runs it through the pager specified
+in C<$CPAN::Config->{pager}>
+
 =item CPAN::Distribution::test()
 
 Changes to the directory where the distribution has been unpacked and
@@ -6611,6 +6815,10 @@
 
 Runs a C<readme> on the distribution associated with this module.
 
+=item CPAN::Module::perldoc()
+
+Runs a C<perldoc> on this module.
+
 =item CPAN::Module::test()
 
 Runs a C<test> on the distribution associated with this module.
