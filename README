    EOF } if ($CPAN::Signal){ $self->safe_chdir($sub_wd); return; }
    $self->safe_chdir("tmp");

        #
        # Unpack the goods
        #
        $self->debug("local_file[$local_file]") if $CPAN::DEBUG;
        my $ct = CPAN::Tarzip->new($local_file);
        if ($local_file =~ /(\.tar\.(bz2|gz|Z)|\.tgz)(?!\n)\Z/i){
            $self->{was_uncompressed}++ unless $ct->gtest();
            $self->untar_me($ct);
        } elsif ( $local_file =~ /\.zip(?!\n)\Z/i ) {
            $self->unzip_me($ct);
        } elsif ( $local_file =~ /\.pm(\.(gz|Z))?(?!\n)\Z/) {
            $self->{was_uncompressed}++ unless $ct->gtest();
            $self->debug("calling pm2dir for local_file[$local_file]") if $CPAN::DEBUG;
            $self->pm2dir_me($local_file);
        } else {
            $self->{archived} = "NO";
            $self->safe_chdir($sub_wd);
            return;
        }

        # we are still in the tmp directory!
        # Let's check if the package has its own directory.
        my $dh = DirHandle->new(File::Spec->curdir)
            or Carp::croak("Couldn't opendir .: $!");
        my @readdir = grep $_ !~ /^\.\.?(?!\n)\Z/s, $dh->read; ### MAC??
        $dh->close;
        my ($distdir,$packagedir);
        if (@readdir == 1 && -d $readdir[0]) {
            $distdir = $readdir[0];
            $packagedir = File::Spec->catdir($builddir,$distdir);
            $self->debug("packagedir[$packagedir]builddir[$builddir]distdir[$distdir]")
                if $CPAN::DEBUG;
            -d $packagedir and $CPAN::Frontend->myprint("Removing previously used ".
                                                        "$packagedir\n");
            File::Path::rmtree($packagedir);
            unless (File::Copy::move($distdir,$packagedir)) {
                my $len1 = length("$builddir/tmp/$distdir");
                my $filler1 = $len1>58 ? "" : " "x(58-$len1)."<==";
                my $len2 = length($packagedir);
                my $filler2 = $len2>58 ? "" : " "x(58-$len2)."<==";
                $CPAN::Frontend->mydie(<<EOF);
    Couldn't move '$distdir' to '$packagedir': $!

    EOF } $self->debug(sprintf("moved distdir[%s] to packagedir[%s]
    -e[%s]-d[%s]", $distdir, $packagedir, -e $packagedir, -d $packagedir, ))
    if $CPAN::DEBUG; } else { my $userid = $self->cpan_userid; unless
    ($userid) { CPAN->debug("no userid? self[$self]"); $userid = "anon"; }
    my $pragmatic_dir = $userid . '000'; $pragmatic_dir =~ s/\W_//g;
    $pragmatic_dir++ while -d "../$pragmatic_dir"; $packagedir =
    File::Spec->catdir($builddir,$pragmatic_dir);
    $self->debug("packagedir[$packagedir]") if $CPAN::DEBUG;
    File::Path::mkpath($packagedir); my($f); for $f (@readdir) { # is
    already without "." and ".." my $to =
    File::Spec->catdir($packagedir,$f); File::Copy::move($f,$to) or
    Carp::confess("Couldn't move $f to $to: $!"); } } if ($CPAN::Signal){
    $self->safe_chdir($sub_wd); return; }

        $self->{'build_dir'} = $packagedir;
        $self->safe_chdir($builddir);
        File::Path::rmtree("tmp");

        $self->safe_chdir($packagedir);
        if ($CPAN::META->has_inst("Module::Signature")) {
            if (-f "SIGNATURE") {
                $self->debug("Module::Signature is installed, verifying") if $CPAN::DEBUG;
                my $rv = Module::Signature::verify();
                if ($rv != Module::Signature::SIGNATURE_OK() and
                    $rv != Module::Signature::SIGNATURE_MISSING()) {
                    $CPAN::Frontend->myprint(
                                             qq{\nSignature invalid for }.
                                             qq{distribution file. }.
                                             qq{Please investigate.\n\n}.
                                             $self->as_string,
                                             $CPAN::META->instance(
                                                                   'CPAN::Author',
                                                                   $self->cpan_userid,
                                                                  )->as_string
                                            );

                    my $wrap =
                        sprintf(qq{I'd recommend removing %s. Its signature
    is invalid. Maybe you have configured your 'urllist' with
    a bad URL. Please check this array with 'o conf urllist', and
    retry. For more information, try opening a subshell with
      look %s
    and there run
      cpansign -v
    },
                                $self->{localfile},
                                $self->pretty_id,
                               );
                    $self->{signature_verify} = CPAN::Distrostatus->new("NO");
                    $CPAN::Frontend->mywarn(Text::Wrap::wrap("","",$wrap));
                    $CPAN::Frontend->mysleep(5) if $CPAN::Frontend->can("mysleep");
                } else {
                    $self->{signature_verify} = CPAN::Distrostatus->new("YES");
                }
            } else {
                $CPAN::Frontend->myprint(qq{Package came without SIGNATURE\n\n});
            }
        } else {
            $self->debug("Module::Signature is NOT installed") if $CPAN::DEBUG;
        }
        $self->safe_chdir($builddir);
        return if $CPAN::Signal;

        my($mpl) = File::Spec->catfile($packagedir,"Makefile.PL");
        my($mpl_exists) = -f $mpl;
        unless ($mpl_exists) {
            # NFS has been reported to have racing problems after the
            # renaming of a directory in some environments.
            # This trick helps.
            sleep 1;
            my $mpldh = DirHandle->new($packagedir)
                or Carp::croak("Couldn't opendir $packagedir: $!");
            $mpl_exists = grep /^Makefile\.PL$/, $mpldh->read;
            $mpldh->close;
        }
        my $prefer_installer = "eumm"; # eumm|mb
        if (-f File::Spec->catfile($packagedir,"Build.PL")) {
            if ($mpl_exists) { # they *can* choose
                if ($CPAN::META->has_inst("Module::Build")) {
                    $prefer_installer = $CPAN::Config->{prefer_installer};
                }
            } else {
                $prefer_installer = "mb";
            }
        }
        if (lc($prefer_installer) eq "mb") {
            $self->{modulebuild} = 1;
        } elsif (! $mpl_exists) {
            $self->debug(sprintf("makefilepl[%s]anycwd[%s]",
                                 $mpl,
                                 CPAN::anycwd(),
                                )) if $CPAN::DEBUG;
            my($configure) = File::Spec->catfile($packagedir,"Configure");
            if (-f $configure) {
                # do we have anything to do?
                $self->{'configure'} = $configure;
            } elsif (-f File::Spec->catfile($packagedir,"Makefile")) {
                $CPAN::Frontend->myprint(qq{
    Package comes with a Makefile and without a Makefile.PL.
    We\'ll try to build it with that Makefile then.
    });
                $self->{writemakefile} = "YES";
                sleep 2;
            } else {
                my $cf = $self->called_for || "unknown";
                if ($cf =~ m|/|) {
                    $cf =~ s|.*/||;
                    $cf =~ s|\W.*||;
                }
                $cf =~ s|[/\\:]||g; # risk of filesystem damage
                $cf = "unknown" unless length($cf);
                $CPAN::Frontend->myprint(qq{Package seems to come without Makefile.PL.
      (The test -f "$mpl" returned false.)
      Writing one on our own (setting NAME to $cf)\a\n});
                $self->{had_no_makefile_pl}++;
                sleep 3;

                # Writing our own Makefile.PL

                my $fh = FileHandle->new;
                $fh->open(">$mpl")
                    or Carp::croak("Could not open >$mpl: $!");
                $fh->print(
    qq{# This Makefile.PL has been autogenerated by the module CPAN.pm
    # because there was no Makefile.PL supplied.
    # Autogenerated on: }.scalar localtime().qq{

    use ExtUtils::MakeMaker; WriteMakefile(NAME => q[$cf]);

    }); $fh->close; } }

        return $self;
    }

    # CPAN::Distribution::untar_me ; sub untar_me { my($self,$ct) = @_;
    $self->{archived} = "tar"; if ($ct->untar()) { $self->{unwrapped} =
    "YES"; } else { $self->{unwrapped} = "NO"; } }

    # CPAN::Distribution::unzip_me ; sub unzip_me { my($self,$ct) = @_;
    $self->{archived} = "zip"; if ($ct->unzip()) { $self->{unwrapped} =
    "YES"; } else { $self->{unwrapped} = "NO"; } return; }

    sub pm2dir_me { my($self,$local_file) = @_; $self->{archived} = "pm"; my
    $to = File::Basename::basename($local_file); if ($to =~
    s/\.(gz|Z)(?!\n)\Z//) { if (CPAN::Tarzip->new($local_file)->gunzip($to))
    { $self->{unwrapped} = "YES"; } else { $self->{unwrapped} = "NO"; } }
    else { File::Copy::cp($local_file,"."); $self->{unwrapped} = "YES"; } }

    #-> sub CPAN::Distribution::new ; sub new { my($class,%att) = @_;

        # $CPAN::META->{cachemgr} ||= CPAN::CacheMgr->new();

        my $this = { %att };
        return bless $this, $class;
    }

    #-> sub CPAN::Distribution::look ; sub look { my($self) = @_;

        if ($^O eq 'MacOS') {
          $self->Mac::BuildTools::look;
          return;
        }

        if (  $CPAN::Config->{'shell'} ) {
            $CPAN::Frontend->myprint(qq{
    Trying to open a subshell in the build directory...
    });
        } else {
            $CPAN::Frontend->myprint(qq{
    Your configuration does not define a value for subshells.
    Please define it with "o conf shell <your shell>"
    });
            return;
        }
        my $dist = $self->id;
        my $dir;
        unless ($dir = $self->dir) {
            $self->get;
        }
        unless ($dir ||= $self->dir) {
            $CPAN::Frontend->mywarn(qq{
    Could not determine which directory to use for looking at $dist.
    });
            return;
        }
        my $pwd  = CPAN::anycwd();
        $self->safe_chdir($dir);
        $CPAN::Frontend->myprint(qq{Working directory is $dir\n});
        {
            local $ENV{CPAN_SHELL_LEVEL} = $ENV{CPAN_SHELL_LEVEL}||0;
            $ENV{CPAN_SHELL_LEVEL} += 1;
            unless (system($CPAN::Config->{'shell'}) == 0) {
                my $code = $? >> 8;
                $CPAN::Frontend->mywarn("Subprocess shell exit code $code\n");
            }
        }
        $self->safe_chdir($pwd);
    }

    # CPAN::Distribution::cvs_import ; sub cvs_import { my($self) = @_;
    $self->get; my $dir = $self->dir;

        my $package = $self->called_for;
        my $module = $CPAN::META->instance('CPAN::Module', $package);
        my $version = $module->cpan_version;

        my $userid = $self->cpan_userid;

        my $cvs_dir = (split /\//, $dir)[-1];
        $cvs_dir =~ s/-\d+[^-]+(?!\n)\Z//;
        my $cvs_root = 
          $CPAN::Config->{cvsroot} || $ENV{CVSROOT};
        my $cvs_site_perl = 
          $CPAN::Config->{cvs_site_perl} || $ENV{CVS_SITE_PERL};
        if ($cvs_site_perl) {
            $cvs_dir = "$cvs_site_perl/$cvs_dir";
        }
        my $cvs_log = qq{"imported $package $version sources"};
        $version =~ s/\./_/g;
        my @cmd = ('cvs', '-d', $cvs_root, 'import', '-m', $cvs_log,
                   "$cvs_dir", $userid, "v$version");

        my $pwd  = CPAN::anycwd();
        chdir($dir) or $CPAN::Frontend->mydie(qq{Could not chdir to "$dir": $!});

        $CPAN::Frontend->myprint(qq{Working directory is $dir\n});

        $CPAN::Frontend->myprint(qq{@cmd\n});
        system(@cmd) == 0 or
            $CPAN::Frontend->mydie("cvs import failed");
        chdir($pwd) or $CPAN::Frontend->mydie(qq{Could not chdir to "$pwd": $!});
    }

    #-> sub CPAN::Distribution::readme ; sub readme { my($self) = @_;
    my($dist) = $self->id; my($sans,$suffix) = $dist =~
    /(.+)\.(tgz|tar[\._-]gz|tar\.Z|zip)$/; $self->debug("sans[$sans]
    suffix[$suffix]\n") if $CPAN::DEBUG; my($local_file); my($local_wanted)
    = File::Spec->catfile( $CPAN::Config->{keep_source_where}, "authors",
    "id", split(/\//,"$sans.readme"), ); $self->debug("Doing localize") if
    $CPAN::DEBUG; $local_file =
    CPAN::FTP->localize("authors/id/$sans.readme", $local_wanted) or
    $CPAN::Frontend->mydie(qq{No $sans.readme found});;

        if ($^O eq 'MacOS') {
            Mac::BuildTools::launch_file($local_file);
            return;
        }

        my $fh_pager = FileHandle->new;
        local($SIG{PIPE}) = "IGNORE";
        $fh_pager->open("|$CPAN::Config->{'pager'}")
            or die "Could not open pager $CPAN::Config->{'pager'}: $!";
        my $fh_readme = FileHandle->new;
        $fh_readme->open($local_file)
            or $CPAN::Frontend->mydie(qq{Could not open "$local_file": $!});
        $CPAN::Frontend->myprint(qq{
    Displaying file
      $local_file
    with pager "$CPAN::Config->{'pager'}"
    });
        sleep 2;
        $fh_pager->print(<$fh_readme>);
        $fh_pager->close;
    }

    #-> sub CPAN::Distribution::verifyCHECKSUM ; sub verifyCHECKSUM {
    my($self) = @_; EXCUSE: { my @e; $self->{CHECKSUM_STATUS} ||= "";
    $self->{CHECKSUM_STATUS} eq "OK" and push @e, "Checksum was ok";
    $CPAN::Frontend->myprint(join "", map {" $_\n"} @e) and return if @e; }
    my($lc_want,$lc_file,@local,$basename); @local = split(/\//,$self->id);
    pop @local; push @local, "CHECKSUMS"; $lc_want =
    File::Spec->catfile($CPAN::Config->{keep_source_where}, "authors", "id",
    @local); local($") = "/"; if ( -s $lc_want &&
    $self->CHECKSUM_check_file($lc_want) ) { return $self->{CHECKSUM_STATUS}
    = "OK"; } $lc_file = CPAN::FTP->localize("authors/id/@local",
    $lc_want,1); unless ($lc_file) { $CPAN::Frontend->myprint("Trying
    $lc_want.gz\n"); $local[-1] .= ".gz"; $lc_file =
    CPAN::FTP->localize("authors/id/@local", "$lc_want.gz",1); if ($lc_file)
    { $lc_file =~ s/\.gz(?!\n)\Z//;
    CPAN::Tarzip->new("$lc_file.gz")->gunzip($lc_file); } else { return; } }
    $self->CHECKSUM_check_file($lc_file); }

    sub SIG_check_file { my($self,$chk_file) = @_; my $rv = eval {
    Module::Signature::_verify($chk_file) };

        if ($rv == Module::Signature::SIGNATURE_OK()) {
            $CPAN::Frontend->myprint("Signature for $chk_file ok\n");
            return $self->{SIG_STATUS} = "OK";
        } else {
            $CPAN::Frontend->myprint(qq{\nSignature invalid for }.
                                     qq{distribution file. }.
                                     qq{Please investigate.\n\n}.
                                     $self->as_string,
                                    $CPAN::META->instance(
                                                            'CPAN::Author',
                                                            $self->cpan_userid
                                                            )->as_string);

            my $wrap = qq{I\'d recommend removing $chk_file. Its signature
    is invalid. Maybe you have configured your 'urllist' with
    a bad URL. Please check this array with 'o conf urllist', and
    retry.};

            $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));
        }
    }

    #-> sub CPAN::Distribution::CHECKSUM_check_file ; sub
    CHECKSUM_check_file { my($self,$chk_file) = @_;
    my($cksum,$file,$basename);

        if ($CPAN::META->has_inst("Module::Signature") and Module::Signature->VERSION >= 0.26) {
            $self->debug("Module::Signature is installed, verifying");
            $self->SIG_check_file($chk_file);
        } else {
            $self->debug("Module::Signature is NOT installed");
        }

        $file = $self->{localfile};
        $basename = File::Basename::basename($file);
        my $fh = FileHandle->new;
        if (open $fh, $chk_file){
            local($/);
            my $eval = <$fh>;
            $eval =~ s/\015?\012/\n/g;
            close $fh;
            my($comp) = Safe->new();
            $cksum = $comp->reval($eval);
            if ($@) {
                rename $chk_file, "$chk_file.bad";
                Carp::confess($@) if $@;
            }
        } else {
            Carp::carp "Could not open $chk_file for reading";
        }

        if (exists $cksum->{$basename}{sha256}) {
            $self->debug("Found checksum for $basename:" .
                         "$cksum->{$basename}{sha256}\n") if $CPAN::DEBUG;

            open($fh, $file);
            binmode $fh;
            my $eq = $self->eq_CHECKSUM($fh,$cksum->{$basename}{sha256});
            $fh->close;
            $fh = CPAN::Tarzip->TIEHANDLE($file);

            unless ($eq) {
              my $dg = Digest::SHA->new(256);
              my($data,$ref);
              $ref = \$data;
              while ($fh->READ($ref, 4096) > 0){
                $dg->add($data);
              }
              my $hexdigest = $dg->hexdigest;
              $eq += $hexdigest eq $cksum->{$basename}{'sha256-ungz'};
            }

            if ($eq) {
              $CPAN::Frontend->myprint("Checksum for $file ok\n");
              return $self->{CHECKSUM_STATUS} = "OK";
            } else {
                $CPAN::Frontend->myprint(qq{\nChecksum mismatch for }.
                                         qq{distribution file. }.
                                         qq{Please investigate.\n\n}.
                                         $self->as_string,
                                         $CPAN::META->instance(
                                                               'CPAN::Author',
                                                               $self->cpan_userid
                                                              )->as_string);

                my $wrap = qq{I\'d recommend removing $file. Its
    checksum is incorrect. Maybe you have configured your 'urllist' with
    a bad URL. Please check this array with 'o conf urllist', and
    retry.};

                $CPAN::Frontend->mydie(Text::Wrap::wrap("","",$wrap));

                # former versions just returned here but this seems a
                # serious threat that deserves a die

                # $CPAN::Frontend->myprint("\n\n");
                # sleep 3;
                # return;
            }
            # close $fh if fileno($fh);
        } else {
            $self->{CHECKSUM_STATUS} ||= "";
            if ($self->{CHECKSUM_STATUS} eq "NIL") {
                $CPAN::Frontend->mywarn(qq{
    Warning: No checksum for $basename in $chk_file.

    The cause for this may be that the file is very new and the checksum has
    not yet been calculated, but it may also be that something is going awry
    right now. }); my $answer = ExtUtils::MakeMaker::prompt("Proceed?",
    "yes"); $answer =~ /^\s*y/i or $CPAN::Frontend->mydie("Aborted."); }
    $self->{CHECKSUM_STATUS} = "NIL"; return; } }

    #-> sub CPAN::Distribution::eq_CHECKSUM ; sub eq_CHECKSUM {
    my($self,$fh,$expect) = @_; my $dg = Digest::SHA->new(256); my($data);
    while (read($fh, $data, 4096)){ $dg->add($data); } my $hexdigest =
    $dg->hexdigest; # warn "fh[$fh] hex[$hexdigest] aexp[$expectMD5]";
    $hexdigest eq $expect; }

    #-> sub CPAN::Distribution::force ;

    # Both CPAN::Modules and CPAN::Distributions know if "force" is in #
    effect by autoinspection, not by inspecting a global variable. One # of
    the reason why this was chosen to work that way was the treatment # of
    dependencies. They should not automatically inherit the force # status.
    But this has the downside that ^C and die() will return to # the prompt
    but will not be able to reset the force_update # attributes. We try to
    correct for it currently in the read_metadata # routine, and immediately
    before we check for a Signal. I hope this # works out in one of
    v1.57_53ff

    sub force { my($self, $method) = @_; for my $att (qw( CHECKSUM_STATUS
    archived build_dir localfile make install unwrapped writemakefile )) {
    delete $self->{$att}; } if ($method && $method =~ /make|test|install/) {
    $self->{"force_update"}++; # name should probably have been
    force_install } }

    sub notest { my($self, $method) = @_; # warn "XDEBUG: set notest for
    $self $method"; $self->{"notest"}++; # name should probably have been
    force_install }

    sub unnotest { my($self) = @_; # warn "XDEBUG: deleting notest"; delete
    $self->{'notest'}; }

    #-> sub CPAN::Distribution::unforce ; sub unforce { my($self) = @_;
    delete $self->{'force_update'}; }

    #-> sub CPAN::Distribution::isa_perl ; sub isa_perl { my($self) = @_; my
    $file = File::Basename::basename($self->id); if ($file =~ m{ ^ perl -?
    (5) ([._-]) ( \d{3}(_[0-4][0-9])? | \d*[24680]\.\d+ ) \.tar[._-]gz
    (?!\n)\Z }xs){ return "$1.$3"; } elsif ($self->cpan_comment &&
    $self->cpan_comment =~ /isa_perl\(.+?\)/){ return $1; } }

    #-> sub CPAN::Distribution::perl ; sub perl { return $CPAN::Perl; }

    #-> sub CPAN::Distribution::make ; sub make { my($self) = @_; my $make =
    $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint(sprintf "Running %s for %s\n", $make,
    $self->id); # Emergency brake if they said install Pippi and get newest
    perl if ($self->isa_perl) { if ( $self->called_for ne $self->id && !
    $self->{force_update} ) { # if we die here, we break bundles
    $CPAN::Frontend->mywarn(sprintf qq{ The most recent version "%s" of the
    module "%s" comes with the current version of perl (%s). I\'ll build
    that only if you ask for something like force install %s or install %s
    }, $CPAN::META->instance( 'CPAN::Module', $self->called_for
    )->cpan_version, $self->called_for, $self->isa_perl, $self->called_for,
    $self->id); sleep 5; return; } } $self->get; EXCUSE: { my @e;
    !$self->{archived} || $self->{archived} eq "NO" and push @e, "Is neither
    a tar nor a zip archive.";

            !$self->{unwrapped} || $self->{unwrapped} eq "NO" and push @e,
            "Had problems unarchiving. Please build manually";

            unless ($self->{force_update}) {
                exists $self->{signature_verify} and $self->{signature_verify}->failed
                    and push @e, "Did not pass the signature test.";
            }

            exists $self->{writemakefile} &&
                $self->{writemakefile} =~ m/ ^ NO\s* ( .* ) /sx and push @e,
                    $1 || "Had some problem writing Makefile";

            defined $self->{'make'} and push @e,
                "Has already been processed within this session";

            exists $self->{later} and length($self->{later}) and
                push @e, $self->{later};

            $CPAN::Frontend->myprint(join "", map {"  $_\n"} @e) and return if @e;
        }
        $CPAN::Frontend->myprint("\n  CPAN.pm: Going to build ".$self->id."\n\n");
        my $builddir = $self->dir or
            $CPAN::Frontend->mydie("PANIC: Cannot determine build directory");
        chdir $builddir or Carp::croak("Couldn't chdir $builddir: $!");
        $self->debug("Changed directory to $builddir") if $CPAN::DEBUG;

        if ($^O eq 'MacOS') {
            Mac::BuildTools::make($self);
            return;
        }

        my $system;
        if ($self->{'configure'}) {
            $system = $self->{'configure'};
        } elsif ($self->{modulebuild}) {
            my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
            $system = "$perl Build.PL $CPAN::Config->{mbuildpl_arg}";
        } else {
            my($perl) = $self->perl or die "Couldn\'t find executable perl\n";
            my $switch = "";
    # This needs a handler that can be turned on or off:
    #       $switch = "-MExtUtils::MakeMaker ".
    #           "-Mops=:default,:filesys_read,:filesys_open,require,chdir"
    #           if $] > 5.00310;
            $system = "$perl $switch Makefile.PL $CPAN::Config->{makepl_arg}";
        }
        unless (exists $self->{writemakefile}) {
            local($SIG{ALRM}) = sub { die "inactivity_timeout reached\n" };
            my($ret,$pid);
            $@ = "";
            if ($CPAN::Config->{inactivity_timeout}) {
                eval {
                    alarm $CPAN::Config->{inactivity_timeout};
                    local $SIG{CHLD}; # = sub { wait };
                    if (defined($pid = fork)) {
                        if ($pid) { #parent
                            # wait;
                            waitpid $pid, 0;
                        } else {    #child
                            # note, this exec isn't necessary if
                            # inactivity_timeout is 0. On the Mac I'd
                            # suggest, we set it always to 0.
                            exec $system;
                        }
                    } else {
                        $CPAN::Frontend->myprint("Cannot fork: $!");
                        return;
                    }
                };
                alarm 0;
                if ($@){
                    kill 9, $pid;
                    waitpid $pid, 0;
                    $CPAN::Frontend->myprint($@);
                    $self->{writemakefile} = "NO $@";
                    $@ = "";
                    return;
                }
            } else {
              $ret = system($system);
              if ($ret != 0) {
                $self->{writemakefile} = "NO '$system' returned status $ret";
                return;
              }
            }
            if (-f "Makefile" || -f "Build") {
              $self->{writemakefile} = "YES";
              delete $self->{make_clean}; # if cleaned before, enable next
            } else {
              $self->{writemakefile} =
                  qq{NO -- Unknown reason.};
              # It's probably worth it to record the reason, so let's retry
              # local $/;
              # my $fh = IO::File->new("$system |"); # STDERR? STDIN?
              # $self->{writemakefile} .= <$fh>;
            }
        }
        if ($CPAN::Signal){
          delete $self->{force_update};
          return;
        }
        if (my @prereq = $self->unsat_prereq){
          return 1 if $self->follow_prereqs(@prereq); # signal success to the queuerunner
        }
        if ($self->{modulebuild}) {
            $system = "./Build $CPAN::Config->{mbuild_arg}";
        } else {
            $system = join " ", _make_command(), $CPAN::Config->{make_arg};
        }
        if (system($system) == 0) {
             $CPAN::Frontend->myprint("  $system -- OK\n");
             $self->{'make'} = CPAN::Distrostatus->new("YES");
        } else {
             $self->{writemakefile} ||= "YES";
             $self->{'make'} = CPAN::Distrostatus->new("NO");
             $CPAN::Frontend->myprint("  $system -- NOT OK\n");
        }
    }

    sub _make_command { return $CPAN::Config->{'make'} ||
    $Config::Config{make} || 'make'; }

    sub follow_prereqs { my($self) = shift; my(@prereq) = grep {$_ ne
    "perl"} @_; return unless @prereq; my $id = $self->id;
    $CPAN::Frontend->myprint("---- Unsatisfied dependencies detected ".
    "during [$id] -----\n");

        for my $p (@prereq) {
            $CPAN::Frontend->myprint("    $p\n");
        }
        my $follow = 0;
        if ($CPAN::Config->{prerequisites_policy} eq "follow") {
            $follow = 1;
        } elsif ($CPAN::Config->{prerequisites_policy} eq "ask") {
            require ExtUtils::MakeMaker;
            my $answer = ExtUtils::MakeMaker::prompt(
    "Shall I follow them and prepend them to the queue
    of modules we are processing right now?", "yes");
            $follow = $answer =~ /^\s*y/i;
        } else {
            local($") = ", ";
            $CPAN::Frontend->
                myprint("  Ignoring dependencies on modules @prereq\n");
        }
        if ($follow) {
            # color them as dirty
            for my $p (@prereq) {
                # warn "calling color_cmd_tmps(0,1)";
                CPAN::Shell->expandany($p)->color_cmd_tmps(0,1);
            }
            CPAN::Queue->jumpqueue(@prereq,$id); # queue them and requeue yourself
            $self->{later} = "Delayed until after prerequisites";
            return 1; # signal success to the queuerunner
        }
    }

    #-> sub CPAN::Distribution::unsat_prereq ; sub unsat_prereq { my($self)
    = @_; my $prereq_pm = $self->prereq_pm or return; my(@need); NEED: while
    (my($need_module, $need_version) = each %$prereq_pm) { my $nmo =
    $CPAN::META->instance("CPAN::Module",$need_module); # we were too
    demanding: next if $nmo->uptodate;

            # if they have not specified a version, we accept any installed one
            if (not defined $need_version or
               $need_version eq "0" or
               $need_version eq "undef") {
                next if defined $nmo->inst_file;
            }

            # We only want to install prereqs if either they're not installed
            # or if the installed version is too old. We cannot omit this
            # check, because if 'force' is in effect, nobody else will check.
            if (defined $nmo->inst_file) {
                my(@all_requirements) = split /\s*,\s*/, $need_version;
                local($^W) = 0;
                my $ok = 0;
              RQ: for my $rq (@all_requirements) {
                    if ($rq =~ s|>=\s*||) {
                    } elsif ($rq =~ s|>\s*||) {
                        # 2005-12: one user
                        if (CPAN::Version->vgt($nmo->inst_version,$rq)){
                            $ok++;
                        }
                        next RQ;
                    } elsif ($rq =~ s|!=\s*||) {
                        # 2005-12: no user
                        if (CPAN::Version->vcmp($nmo->inst_version,$rq)){
                            $ok++;
                            next RQ;
                        } else {
                            last RQ;
                        }
                    } elsif ($rq =~ m|<=?\s*|) {
                        # 2005-12: no user
                        $CPAN::Frontend->mywarn("Downgrading not supported (rq[$rq])");
                        $ok++;
                        next RQ;
                    }
                    if (! CPAN::Version->vgt($rq, $nmo->inst_version)){
                        $ok++;
                    }
                    CPAN->debug(sprintf "id[%s]inst_file[%s]inst_version[%s]rq[%s]ok[%d]",
                                $nmo->id,
                                $nmo->inst_file,
                                $nmo->inst_version,
                                CPAN::Version->readable($rq),
                                $ok,
                               ) if $CPAN::DEBUG;
                }
                next NEED if $ok == @all_requirements;
            }

            if ($self->{sponsored_mods}{$need_module}++){
                # We have already sponsored it and for some reason it's still
                # not available. So we do nothing. Or what should we do?
                # if we push it again, we have a potential infinite loop
                next;
            }
            push @need, $need_module;
        }
        @need;
    }

    #-> sub CPAN::Distribution::read_yaml ; sub read_yaml { my($self) = @_;
    return $self->{yaml_content} if exists $self->{yaml_content}; my
    $build_dir = $self->{build_dir}; my $yaml =
    File::Spec->catfile($build_dir,"META.yml"); return unless -f $yaml; if
    ($CPAN::META->has_inst("YAML")) { eval { $self->{yaml_content} =
    YAML::LoadFile($yaml); }; if ($@) { $CPAN::Frontend->mywarn("Error while
    parsing META.yml: $@"); return; } } return $self->{yaml_content}; }

    #-> sub CPAN::Distribution::prereq_pm ; sub prereq_pm { my($self) = @_;
    return $self->{prereq_pm} if exists $self->{prereq_pm_detected} &&
    $self->{prereq_pm_detected}; return unless $self->{writemakefile} # no
    need to have succeeded # but we must have run it ||
    $self->{modulebuild}; my $req; if (my $yaml = $self->read_yaml) { $req =
    $yaml->{requires}; undef $req unless ref $req eq "HASH" && %$req; if
    ($req) { if ($yaml->{generated_by} =~ /ExtUtils::MakeMaker version
    ([\d\._]+)/) { my $eummv = do { local $^W = 0; $1+0; }; if ($eummv <
    6.2501) { # thanks to Slaven for digging that out: MM before # that
    could be wrong because it could reflect a # previous release undef $req;
    } } my $areq; my $do_replace; while (my($k,$v) = each %{$req||{}}) { if
    ($v =~ /\d/) { $areq->{$k} = $v; } elsif ($k =~ /[A-Za-z]/ && $v =~
    /[A-Za-z]/ && $CPAN::META->exists("Module",$v) ) {
    $CPAN::Frontend->mywarn("Suspicious key-value pair in META.yml's ".
    "requires hash: $k => $v; I'll take both ". "key and value as a module
    name\n"); sleep 1; $areq->{$k} = 0; $areq->{$v} = 0; $do_replace++; } }
    $req = $areq if $do_replace; } if ($req) { delete $req->{perl}; } }
    unless ($req) { my $build_dir = $self->{build_dir} or die "Panic: no
    build_dir?"; my $makefile = File::Spec->catfile($build_dir,"Makefile");
    my $fh; if (-f $makefile and $fh = FileHandle->new("<$makefile\0")) {
    local($/) = "\n"; while (<$fh>) { last if /MakeMaker post_initialize
    section/; my($p) = m{^[\#] \s+PREREQ_PM\s+=>\s+(.+) }x; next unless $p;
    # warn "Found prereq expr[$p]";

                    #  Regexp modified by A.Speer to remember actual version of file
                    #  PREREQ_PM hash key wants, then add to
                    while ( $p =~ m/(?:\s)([\w\:]+)=>q\[(.*?)\],?/g ){
                        # In case a prereq is mentioned twice, complain.
                        if ( defined $req->{$1} ) {
                            warn "Warning: PREREQ_PM mentions $1 more than once, ".
                                "last mention wins";
                        }
                        $req->{$1} = $2;
                    }
                    last;
                }
            } elsif (-f "Build") {
                if ($CPAN::META->has_inst("Module::Build")) {
                    $req = Module::Build->current->requires();
                }
            }
        }
        if (-f "Build.PL" && ! -f "Makefile.PL" && ! exists $req->{"Module::Build"}) {
            $CPAN::Frontend->mywarn("  Warning: CPAN.pm discovered Module::Build as ".
                                    "undeclared prerequisite.\n".
                                    "  Adding it now as a prerequisite.\n"
                                   );
            $CPAN::Frontend->mysleep(5);
            $req->{"Module::Build"} = 0;
            delete $self->{writemakefile};
        }
        $self->{prereq_pm_detected}++;
        return $self->{prereq_pm} = $req;
    }

    #-> sub CPAN::Distribution::test ; sub test { my($self) = @_;
    $self->make; if ($CPAN::Signal){ delete $self->{force_update}; return; }
    # warn "XDEBUG: checking for notest: $self->{notest} $self"; if
    ($self->{notest}) { $CPAN::Frontend->myprint("Skipping test because of
    notest pragma\n"); return 1; }

        my $make = $self->{modulebuild} ? "Build" : "make";
        $CPAN::Frontend->myprint("Running $make test\n");
        if (my @prereq = $self->unsat_prereq){
          return 1 if $self->follow_prereqs(@prereq); # signal success to the queuerunner
        }
      EXCUSE: {
            my @e;
            exists $self->{make} or exists $self->{later} or push @e,
            "Make had some problems, maybe interrupted? Won't test";

            exists $self->{'make'} and
                $self->{'make'}->failed and
                    push @e, "Can't test without successful make";

            exists $self->{build_dir} or push @e, "Has no own directory";
            $self->{badtestcnt} ||= 0;
            $self->{badtestcnt} > 0 and
                push @e, "Won't repeat unsuccessful test during this command";

            exists $self->{later} and length($self->{later}) and
                push @e, $self->{later};

            $CPAN::Frontend->myprint(join "", map {"  $_\n"} @e) and return if @e;
        }
        chdir $self->{'build_dir'} or
            Carp::croak("Couldn't chdir to $self->{'build_dir'}");
        $self->debug("Changed directory to $self->{'build_dir'}")
            if $CPAN::DEBUG;

        if ($^O eq 'MacOS') {
            Mac::BuildTools::make_test($self);
            return;
        }

        local $ENV{PERL5LIB} = defined($ENV{PERL5LIB})
                               ? $ENV{PERL5LIB}
                               : ($ENV{PERLLIB} || "");

        $CPAN::META->set_perl5lib;
        my $system;
        if ($self->{modulebuild}) {
            $system = "./Build test";
        } else {
            $system = join " ", _make_command(), "test";
        }
        if (system($system) == 0) {
             $CPAN::Frontend->myprint("  $system -- OK\n");
             $CPAN::META->is_tested($self->{'build_dir'});
             $self->{make_test} = CPAN::Distrostatus->new("YES");
        } else {
             $self->{make_test} = CPAN::Distrostatus->new("NO");
             $self->{badtestcnt}++;
             $CPAN::Frontend->myprint("  $system -- NOT OK\n");
        }
    }

    #-> sub CPAN::Distribution::clean ; sub clean { my($self) = @_; my $make
    = $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint("Running $make clean\n"); unless (exists
    $self->{build_dir}) { $CPAN::Frontend->mywarn("Distribution has no own
    directory, nothing to do.\n"); return 1; } EXCUSE: { my @e; exists
    $self->{make_clean} and $self->{make_clean} eq "YES" and push @e, "make
    clean already called once"; $CPAN::Frontend->myprint(join "", map {"
    $_\n"} @e) and return if @e; } chdir $self->{'build_dir'} or
    Carp::croak("Couldn't chdir to $self->{'build_dir'}");
    $self->debug("Changed directory to $self->{'build_dir'}") if
    $CPAN::DEBUG;

        if ($^O eq 'MacOS') {
            Mac::BuildTools::make_clean($self);
            return;
        }

        my $system;
        if ($self->{modulebuild}) {
            $system = "./Build clean";
        } else {
            $system  = join " ", _make_command(), "clean";
        }
        if (system($system) == 0) {
          $CPAN::Frontend->myprint("  $system -- OK\n");

          # $self->force;

          # Jost Krieger pointed out that this "force" was wrong because
          # it has the effect that the next "install" on this distribution
          # will untar everything again. Instead we should bring the
          # object's state back to where it is after untarring.

          for my $k (qw(
                        force_update
                        install
                        writemakefile
                        make
                        make_test
                       )) {
              delete $self->{$k};
          }
          $self->{make_clean} = "YES";

        } else {
          # Hmmm, what to do if make clean failed?

          $CPAN::Frontend->myprint(qq{  $system -- NOT OK

    make clean did not succeed, marking directory as unusable for further
    work. }); $self->force("make"); # so that this directory won't be used
    again

        }
    }

    #-> sub CPAN::Distribution::install ; sub install { my($self) = @_;
    $self->test; if ($CPAN::Signal){ delete $self->{force_update}; return; }
    my $make = $self->{modulebuild} ? "Build" : "make";
    $CPAN::Frontend->myprint("Running $make install\n"); EXCUSE: { my @e;
    exists $self->{build_dir} or push @e, "Has no own directory";

            exists $self->{make} or exists $self->{later} or push @e,
            "Make had some problems, maybe interrupted? Won't install";

            exists $self->{'make'} and
                $self->{'make'}->failed and
                    push @e, "make had returned bad status, install seems impossible";

            if (exists $self->{make_test} and
                $self->{make_test}->failed){
                if ($self->{force_update}) {
                    $self->{make_test}->text("FAILED but failure ignored because ".
                                             "'force' in effect");
                } else {
                    push @e, "make test had returned bad status, ".
                        "won't install without force"
                }
            }
            exists $self->{'install'} and push @e,
            $self->{'install'}->text eq "YES" ?
                "Already done" : "Already tried without success";

            exists $self->{later} and length($self->{later}) and
                push @e, $self->{later};

            $CPAN::Frontend->myprint(join "", map {"  $_\n"} @e) and return if @e;
        }
        chdir $self->{'build_dir'} or
            Carp::croak("Couldn't chdir to $self->{'build_dir'}");
        $self->debug("Changed directory to $self->{'build_dir'}")
            if $CPAN::DEBUG;

        if ($^O eq 'MacOS') {
            Mac::BuildTools::make_install($self);
            return;
        }

        my $system;
        if ($self->{modulebuild}) {
            my($mbuild_install_build_command) = $CPAN::Config->{'mbuild_install_build_command'} ||
                "./Build";
            $system = join(" ",
                           $mbuild_install_build_command,
                           "install",
                           $CPAN::Config->{mbuild_install_arg},
                          );
        } else {
            my($make_install_make_command) = $CPAN::Config->{'make_install_make_command'} ||
                _make_command();
            $system = join(" ",
                           $make_install_make_command,
                           "install",
                           $CPAN::Config->{make_install_arg},
                          );
        }

        my($stderr) = $^O =~ /Win/i ? "" : " 2>&1 ";
        my($pipe) = FileHandle->new("$system $stderr |");
        my($makeout) = "";
        while (<$pipe>){
            $CPAN::Frontend->myprint($_);
            $makeout .= $_;
        }
        $pipe->close;
        if ($?==0) {
             $CPAN::Frontend->myprint("  $system -- OK\n");
             $CPAN::META->is_installed($self->{'build_dir'});
             return $self->{'install'} = CPAN::Distrostatus->new("YES");
        } else {
             $self->{'install'} = CPAN::Distrostatus->new("NO");
             $CPAN::Frontend->myprint("  $system -- NOT OK\n");
             if (
                 $makeout =~ /permission/s
                 && $> > 0
                 && (
                     ! $CPAN::Config->{make_install_make_command}
                     || $CPAN::Config->{make_install_make_command} eq $CPAN::Config->{make}
                    )
                ) {
                 $CPAN::Frontend->myprint(
                                          qq{----\n}.
                                          qq{  You may have to su }.
                                          qq{to root to install the package\n}.
                                          qq{  (Or you may want to run something like\n}.
                                          qq{    o conf make_install_make_command 'sudo make'\n}.
                                          qq{  to raise your permissions.}
                                         );
             }
        }
        delete $self->{force_update};
    }

    #-> sub CPAN::Distribution::dir ; sub dir { shift->{'build_dir'}; }

    #-> sub CPAN::Distribution::perldoc ; sub perldoc { my($self) = @_;

        my($dist) = $self->id;
        my $package = $self->called_for;

        $self->_display_url( $CPAN::Defaultdocs . $package );
    }

    #-> sub CPAN::Distribution::_check_binary ; sub _check_binary { my
    ($dist,$shell,$binary) = @_; my ($pid,$readme,$out);

        $CPAN::Frontend->myprint(qq{ + _check_binary($binary)\n})
          if $CPAN::DEBUG;

        $pid = open $readme, "which $binary|"
          or $CPAN::Frontend->mydie(qq{Could not fork 'which $binary': $!});
        while (<$readme>) {
            $out .= $_;
        }
        close $readme or die "Could not run 'which $binary': $!";

        $CPAN::Frontend->myprint(qq{   + $out \n})
          if $CPAN::DEBUG && $out;

        return $out;
    }

    #-> sub CPAN::Distribution::_display_url ; sub _display_url {
    my($self,$url) = @_; my($res,$saved_file,$pid,$readme,$out);

        $CPAN::Frontend->myprint(qq{ + _display_url($url)\n})
          if $CPAN::DEBUG;

        # should we define it in the config instead?
        my $html_converter = "html2text";

        my $web_browser = $CPAN::Config->{'lynx'} || undef;
        my $web_browser_out = $web_browser
          ? CPAN::Distribution->_check_binary($self,$web_browser)
            : undef;

        my ($tmpout,$tmperr);
        if (not $web_browser_out) {
            # web browser not found, let's try text only
            my $html_converter_out =
              CPAN::Distribution->_check_binary($self,$html_converter);

            if ($html_converter_out ) {
                # html2text found, run it
                $saved_file = CPAN::Distribution->_getsave_url( $self, $url );
                $CPAN::Frontend->myprint(qq{ERROR: problems while getting $url, $!\n})
                  unless defined($saved_file);

                $pid = open $readme, "$html_converter $saved_file |"
                  or $CPAN::Frontend->mydie(qq{
    Could not fork '$html_converter $saved_file': $!});
                my $fh = File::Temp->new(
                                         template => 'cpan_htmlconvert_XXXX',
                                         suffix => '.txt',
                                         unlink => 0,
                                        );
                while (<$readme>) {
                    $fh->print($_);
                }
                close $readme
                  or $CPAN::Frontend->mydie(qq{Could not run '$html_converter $saved_file': $!});
                my $tmpin = $fh->filename;
                $CPAN::Frontend->myprint(sprintf(qq{
    Run '%s %s' and
    saved output to %s\n},
                                                 $html_converter,
                                                 $saved_file,
                                                 $tmpin,
                                                )) if $CPAN::DEBUG;
                close $fh; undef $fh;
                open $fh, $tmpin
                  or $CPAN::Frontend->mydie(qq{Could not open "$tmpin": $!});
                my $fh_pager = FileHandle->new;
                local($SIG{PIPE}) = "IGNORE";
                $fh_pager->open("|$CPAN::Config->{'pager'}")
                  or $CPAN::Frontend->mydie(qq{
    Could not open pager $CPAN::Config->{'pager'}: $!});
                $CPAN::Frontend->myprint(qq{
    Displaying URL
      $url
    with pager "$CPAN::Config->{'pager'}"
    });
                sleep 2;
                $fh_pager->print(<$fh>);
                $fh_pager->close;
            } else {
                # coldn't find the web browser or html converter
                $CPAN::Frontend->myprint(qq{
    You need to install lynx or $html_converter to use this feature.});
            }
        } else {
            # web browser found, run the action
            my $browser = $CPAN::Config->{'lynx'};
            $CPAN::Frontend->myprint(qq{system[$browser $url]})
              if $CPAN::DEBUG;
            $CPAN::Frontend->myprint(qq{
    Displaying URL
      $url
    with browser $browser
    });
            sleep 2;
            system("$browser $url");
            if ($saved_file) { 1 while unlink($saved_file) }
        }
    }

    #-> sub CPAN::Distribution::_getsave_url ; sub _getsave_url { my($dist,
    $shell, $url) = @_;

        $CPAN::Frontend->myprint(qq{ + _getsave_url($url)\n})
          if $CPAN::DEBUG;

        my $fh  = File::Temp->new(
                                  template => "cpan_getsave_url_XXXX",
                                  suffix => ".html",
                                  unlink => 0,
                                 );
        my $tmpin = $fh->filename;
        if ($CPAN::META->has_usable('LWP')) {
            $CPAN::Frontend->myprint("Fetching with LWP:
      $url
    ");
            my $Ua;
            CPAN::LWP::UserAgent->config;
            eval { $Ua = CPAN::LWP::UserAgent->new; };
            if ($@) {
                $CPAN::Frontend->mywarn("ERROR: CPAN::LWP::UserAgent->new dies with $@\n");
                return;
            } else {
                my($var);
                $Ua->proxy('http', $var)
                    if $var = $CPAN::Config->{http_proxy} || $ENV{http_proxy};
                $Ua->no_proxy($var)
                    if $var = $CPAN::Config->{no_proxy} || $ENV{no_proxy};
            }

            my $req = HTTP::Request->new(GET => $url);
            $req->header('Accept' => 'text/html');
            my $res = $Ua->request($req);
            if ($res->is_success) {
                $CPAN::Frontend->myprint(" + request successful.\n")
                    if $CPAN::DEBUG;
                print $fh $res->content;
                close $fh;
                $CPAN::Frontend->myprint(qq{ + saved content to $tmpin \n})
                    if $CPAN::DEBUG;
                return $tmpin;
            } else {
                $CPAN::Frontend->myprint(sprintf(
                                                 "LWP failed with code[%s], message[%s]\n",
                                                 $res->code,
                                                 $res->message,
                                                ));
                return;
            }
        } else {
            $CPAN::Frontend->myprint("LWP not available\n");
            return;
        }
    }

    package CPAN::Bundle; use strict;

    sub look { my $self = shift; $CPAN::Frontend->myprint($self->as_string);
    }

    sub undelay { my $self = shift; delete $self->{later}; for my $c (
    $self->contains ) { my $obj = CPAN::Shell->expandany($c) or next;
    $obj->undelay; } }

    # mark as dirty/clean #-> sub CPAN::Bundle::color_cmd_tmps ; sub
    color_cmd_tmps { my($self) = shift; my($depth) = shift || 0; my($color)
    = shift || 0; my($ancestors) = shift || []; # a module needs to recurse
    to its cpan_file, a distribution needs # to recurse into its prereq_pms,
    a bundle needs to recurse into its modules

        return if exists $self->{incommandcolor}
            && $self->{incommandcolor}==$color;
        if ($depth>=100){
            $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
        }
        # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;

        for my $c ( $self->contains ) {
            my $obj = CPAN::Shell->expandany($c) or next;
            CPAN->debug("c[$c]obj[$obj]") if $CPAN::DEBUG;
            $obj->color_cmd_tmps($depth+1,$color,[@$ancestors, $self->id]);
        }
        if ($color==0) {
            delete $self->{badtestcnt};
        }
        $self->{incommandcolor} = $color;
    }

    #-> sub CPAN::Bundle::as_string ; sub as_string { my($self) = @_;
    $self->contains; # following line must be "=", not "||=" because we have
    a moving target $self->{INST_VERSION} = $self->inst_version; return
    $self->SUPER::as_string; }

    #-> sub CPAN::Bundle::contains ; sub contains { my($self) = @_;
    my($inst_file) = $self->inst_file || ""; my($id) = $self->id;
    $self->debug("inst_file[$inst_file]id[$id]") if $CPAN::DEBUG; unless
    ($inst_file) { # Try to get at it in the cpan directory $self->debug("no
    inst_file") if $CPAN::DEBUG; my $cpan_file; $CPAN::Frontend->mydie("I
    don't know a bundle with ID $id\n") unless $cpan_file =
    $self->cpan_file; if ($cpan_file eq "N/A") {
    $CPAN::Frontend->mydie("Bundle $id not found on disk and not on CPAN.
    Maybe stale symlink? Maybe removed during session? Giving up.\n"); } my
    $dist = $CPAN::META->instance('CPAN::Distribution', $self->cpan_file);
    $dist->get; $self->debug($dist->as_string) if $CPAN::DEBUG; my($todir) =
    $CPAN::Config->{'cpan_home'}; my(@me,$from,$to,$me); @me = split /::/,
    $self->id; $me[-1] .= ".pm"; $me = File::Spec->catfile(@me); $from =
    $self->find_bundle_file($dist->{'build_dir'},$me); $to =
    File::Spec->catfile($todir,$me);
    File::Path::mkpath(File::Basename::dirname($to));
    File::Copy::copy($from, $to) or Carp::confess("Couldn't copy $from to
    $to: $!"); $inst_file = $to; } my @result; my $fh = FileHandle->new;
    local $/ = "\n"; open($fh,$inst_file) or die "Could not open
    '$inst_file': $!"; my $in_cont = 0;
    $self->debug("inst_file[$inst_file]") if $CPAN::DEBUG; while (<$fh>) {
    $in_cont = m/^=(?!head1\s+CONTENTS)/ ? 0 : m/^=head1\s+CONTENTS/ ? 1 :
    $in_cont; next unless $in_cont; next if /^=/; s/\#.*//; next if /^\s+$/;
    chomp; push @result, (split " ", $_, 2)[0]; } close $fh; delete
    $self->{STATUS}; $self->{CONTAINS} = \@result;
    $self->debug("CONTAINS[@result]") if $CPAN::DEBUG; unless (@result) {
    $CPAN::Frontend->mywarn(qq{ The bundle file "$inst_file" may be a broken
    bundlefile. It seems not to contain any bundle definition. Please check
    the file and if it is bogus, please delete it. Sorry for the
    inconvenience. }); } @result; }

    #-> sub CPAN::Bundle::find_bundle_file sub find_bundle_file {
    my($self,$where,$what) = @_; $self->debug("where[$where]what[$what]") if
    $CPAN::DEBUG; ### The following two lines let CPAN.pm become
    Bundle/CPAN.pm :-( ### my $bu = File::Spec->catfile($where,$what); ###
    return $bu if -f $bu; my $manifest =
    File::Spec->catfile($where,"MANIFEST"); unless (-f $manifest) { require
    ExtUtils::Manifest; my $cwd = CPAN::anycwd(); chdir $where or
    $CPAN::Frontend->mydie(qq{Could not chdir to "$where": $!});
    ExtUtils::Manifest::mkmanifest(); chdir $cwd or
    $CPAN::Frontend->mydie(qq{Could not chdir to "$cwd": $!}); } my $fh =
    FileHandle->new($manifest) or Carp::croak("Couldn't open $manifest:
    $!"); local($/) = "\n"; my $what2 = $what; if ($^O eq 'MacOS') { $what
    =~ s/^://; $what =~ tr|:|/|; $what2 =~ s/:Bundle://; $what2 =~ tr|:|/|;
    } else { $what2 =~ s|Bundle[/\\]||; } my $bu; while (<$fh>) { next if
    /^\s*\#/; my($file) = /(\S+)/; if ($file =~ m|\Q$what\E$|) { $bu =
    $file; # return File::Spec->catfile($where,$bu); # bad last; } # retry
    if she managed to # have no Bundle directory $bu = $file if $file =~
    m|\Q$what2\E$|; } $bu =~ tr|/|:| if $^O eq 'MacOS'; return
    File::Spec->catfile($where, $bu) if $bu; Carp::croak("Couldn't find a
    Bundle file in $where"); }

    # needs to work quite differently from Module::inst_file because of #
    cpan_home/Bundle/ directory and the possibility that we have # shadowing
    effect. As it makes no sense to take the first in @INC for # Bundles, we
    parse them all for $VERSION and take the newest.

    #-> sub CPAN::Bundle::inst_file ; sub inst_file { my($self) = @_;
    my($inst_file); my(@me); @me = split /::/, $self->id; $me[-1] .= ".pm";
    my($incdir,$bestv); foreach $incdir ($CPAN::Config->{'cpan_home'},@INC)
    { my $bfile = File::Spec->catfile($incdir, @me);
    CPAN->debug("bfile[$bfile]") if $CPAN::DEBUG; next unless -f $bfile; my
    $foundv = MM->parse_version($bfile); if (!$bestv ||
    CPAN::Version->vgt($foundv,$bestv)) { $self->{INST_FILE} = $bfile;
    $self->{INST_VERSION} = $bestv = $foundv; } } $self->{INST_FILE}; }

    #-> sub CPAN::Bundle::inst_version ; sub inst_version { my($self) = @_;
    $self->inst_file; # finds INST_VERSION as side effect
    $self->{INST_VERSION}; }

    #-> sub CPAN::Bundle::rematein ; sub rematein { my($self,$meth) = @_;
    $self->debug("self[$self] meth[$meth]") if $CPAN::DEBUG; my($id) =
    $self->id; Carp::croak "Can't $meth $id, don't have an associated bundle
    file. :-(\n" unless $self->inst_file || $self->cpan_file; my($s,%fail);
    for $s ($self->contains) { my($type) = $s =~ m|/| ? 'CPAN::Distribution'
    : $s =~ m|^Bundle::| ? 'CPAN::Bundle' : 'CPAN::Module'; if ($type eq
    'CPAN::Distribution') { $CPAN::Frontend->mywarn(qq{ The Bundle
    }.$self->id.qq{ contains explicitly a file $s. }); sleep 3; } # possibly
    noisy action: $self->debug("type[$type] s[$s]") if $CPAN::DEBUG; my $obj
    = $CPAN::META->instance($type,$s); $obj->$meth(); if
    ($obj->isa('CPAN::Bundle') && exists $obj->{install_failed} &&
    ref($obj->{install_failed}) eq "HASH" ) { for (keys
    %{$obj->{install_failed}}) { $self->{install_failed}{$_} = undef; #
    propagate faiure up # to me in a # recursive call $fail{$s} = 1; # the
    bundle itself may have succeeded but # not all children } } else { my
    $success; $success = $obj->can("uptodate") ? $obj->uptodate : 0;
    $success ||= $obj->{'install'} && $obj->{'install'} eq "YES"; if
    ($success) { delete $self->{install_failed}{$s}; } else { $fail{$s} = 1;
    } } }

        # recap with less noise
        if ( $meth eq "install" ) {
            if (%fail) {
                require Text::Wrap;
                my $raw = sprintf(qq{Bundle summary:
    The following items in bundle %s had installation problems:},
                                  $self->id
                                 );
                $CPAN::Frontend->myprint(Text::Wrap::fill("","",$raw));
                $CPAN::Frontend->myprint("\n");
                my $paragraph = "";
                my %reported;
                for $s ($self->contains) {
                  if ($fail{$s}){
                    $paragraph .= "$s ";
                    $self->{install_failed}{$s} = undef;
                    $reported{$s} = undef;
                  }
                }
                my $report_propagated;
                for $s (sort keys %{$self->{install_failed}}) {
                  next if exists $reported{$s};
                  $paragraph .= "and the following items had problems
    during recursive bundle calls: " unless $report_propagated++;
                  $paragraph .= "$s ";
                }
                $CPAN::Frontend->myprint(Text::Wrap::fill("  ","  ",$paragraph));
                $CPAN::Frontend->myprint("\n");
            } else {
                $self->{'install'} = 'YES';
            }
        }
    }

    #sub CPAN::Bundle::xs_file sub xs_file { # If a bundle contains another
    that contains an xs_file we have # here, we just don't bother I suppose
    return 0; }

    #-> sub CPAN::Bundle::force ; sub force { shift->rematein('force',@_); }
    #-> sub CPAN::Bundle::notest ; sub notest {
    shift->rematein('notest',@_); } #-> sub CPAN::Bundle::get ; sub get {
    shift->rematein('get',@_); } #-> sub CPAN::Bundle::make ; sub make {
    shift->rematein('make',@_); } #-> sub CPAN::Bundle::test ; sub test { my
    $self = shift; $self->{badtestcnt} ||= 0; $self->rematein('test',@_); }
    #-> sub CPAN::Bundle::install ; sub install { my $self = shift;
    $self->rematein('install',@_); } #-> sub CPAN::Bundle::clean ; sub clean
    { shift->rematein('clean',@_); }

    #-> sub CPAN::Bundle::uptodate ; sub uptodate { my($self) = @_; return 0
    unless $self->SUPER::uptodate; # we mut have the current Bundle def my
    $c; foreach $c ($self->contains) { my $obj = CPAN::Shell->expandany($c);
    return 0 unless $obj->uptodate; } return 1; }

    #-> sub CPAN::Bundle::readme ; sub readme { my($self) = @_; my($file) =
    $self->cpan_file or $CPAN::Frontend->myprint(qq{ No File found for
    bundle } . $self->id . qq{\n}), return; $self->debug("self[$self]
    file[$file]") if $CPAN::DEBUG;
    $CPAN::META->instance('CPAN::Distribution',$file)->readme; }

    package CPAN::Module; use strict;

    # Accessors # sub CPAN::Module::userid sub userid { my $self = shift; my
    $ro = $self->ro; return unless $ro; return $ro->{userid} ||
    $ro->{CPAN_USERID}; } # sub CPAN::Module::description sub description {
    my $self = shift; my $ro = $self->ro or return ""; $ro->{description} }

    sub distribution { my($self) = @_;
    CPAN::Shell->expand("Distribution",$self->cpan_file); }

    sub undelay { my $self = shift; delete $self->{later}; if ( my $dist =
    CPAN::Shell->expand("Distribution", $self->cpan_file) ) {
    $dist->undelay; } }

    # mark as dirty/clean #-> sub CPAN::Module::color_cmd_tmps ; sub
    color_cmd_tmps { my($self) = shift; my($depth) = shift || 0; my($color)
    = shift || 0; my($ancestors) = shift || []; # a module needs to recurse
    to its cpan_file

        return if exists $self->{incommandcolor}
            && $self->{incommandcolor}==$color;
        return if $depth>=1 && $self->uptodate;
        if ($depth>=100){
            $CPAN::Frontend->mydie(CPAN::Exception::RecursiveDependency->new($ancestors));
        }
        # warn "color_cmd_tmps $depth $color " . $self->id; # sleep 1;

        if ( my $dist = CPAN::Shell->expand("Distribution", $self->cpan_file) ) {
            $dist->color_cmd_tmps($depth+1,$color,[@$ancestors, $self->id]);
        }
        if ($color==0) {
            delete $self->{badtestcnt};
        }
        $self->{incommandcolor} = $color;
    }

    #-> sub CPAN::Module::as_glimpse ; sub as_glimpse { my($self) = @_;
    my(@m); my $class = ref($self); $class =~ s/^CPAN:://; my $color_on =
    ""; my $color_off = ""; if ( $CPAN::Shell::COLOR_REGISTERED &&
    $CPAN::META->has_inst("Term::ANSIColor") && $self->description ) {
    $color_on = Term::ANSIColor::color("green"); $color_off =
    Term::ANSIColor::color("reset"); } push @m, sprintf("%-15s %s%-15s%s
    (%s)\n", $class, $color_on, $self->id, $color_off, $self->cpan_file);
    join "", @m; }

    #-> sub CPAN::Module::as_string ; sub as_string { my($self) = @_;
    my(@m); CPAN->debug("$self entering as_string") if $CPAN::DEBUG; my
    $class = ref($self); $class =~ s/^CPAN:://; local($^W) = 0; push @m,
    $class, " id = $self->{ID}\n"; my $sprintf = " %-12s %s\n"; push @m,
    sprintf($sprintf, 'DESCRIPTION', $self->description) if
    $self->description; my $sprintf2 = " %-12s %s (%s)\n"; my($userid);
    $userid = $self->userid; if ( $userid ){ my $author; if ($author =
    CPAN::Shell->expand('Author',$userid)) { my $email = ""; my $m; # old
    perls if ($m = $author->email) { $email = " <$m>"; } push @m, sprintf(
    $sprintf2, 'CPAN_USERID', $userid, $author->fullname . $email ); } }
    push @m, sprintf($sprintf, 'CPAN_VERSION', $self->cpan_version) if
    $self->cpan_version; if (my $cpan_file = $self->cpan_file){ push @m,
    sprintf($sprintf, 'CPAN_FILE', $cpan_file); if (my $dist =
    CPAN::Shell->expand("Distribution",$cpan_file)) { my $upload_date =
    $dist->upload_date; if ($upload_date) { push @m, sprintf($sprintf,
    'UPLOAD_DATE', $upload_date); } } } my $sprintf3 = " %-12s %1s%1s%1s%1s
    (%s,%s,%s,%s)\n"; my(%statd,%stats,%statl,%stati); @statd{qw,? i c a b R
    M S,} = qw,unknown idea pre-alpha alpha beta released mature standard,;
    @stats{qw,? m d u n a,} = qw,unknown mailing-list developer
    comp.lang.perl.* none abandoned,; @statl{qw,? p c + o h,} = qw,unknown
    perl C C++ other hybrid,; @stati{qw,? f r O h,} = qw,unknown functions
    references+ties object-oriented hybrid,; $statd{' '} = 'unknown';
    $stats{' '} = 'unknown'; $statl{' '} = 'unknown'; $stati{' '} =
    'unknown'; my $ro = $self->ro; push @m, sprintf( $sprintf3,
    'DSLI_STATUS', $ro->{statd}, $ro->{stats}, $ro->{statl}, $ro->{stati},
    $statd{$ro->{statd}}, $stats{$ro->{stats}}, $statl{$ro->{statl}},
    $stati{$ro->{stati}} ) if $ro && $ro->{statd}; my $local_file =
    $self->inst_file; unless ($self->{MANPAGE}) { if ($local_file) {
    $self->{MANPAGE} = $self->manpage_headline($local_file); } else { # If
    we have already untarred it, we should look there my $dist =
    $CPAN::META->instance('CPAN::Distribution', $self->cpan_file); # warn
    "dist[$dist]"; # mff=manifest file; mfh=manifest handle my($mff,$mfh);
    if ( $dist->{build_dir} and (-f ($mff =
    File::Spec->catfile($dist->{build_dir}, "MANIFEST"))) and $mfh =
    FileHandle->new($mff) ) { CPAN->debug("mff[$mff]") if $CPAN::DEBUG; my
    $lfre = $self->id; # local file RE $lfre =~ s/::/./g; $lfre .=
    "\\.pm\$"; my($lfl); # local file file local $/ = "\n"; my(@mflines) =
    <$mfh>; for (@mflines) { s/^\s+//; s/\s.*//s; } while (length($lfre)>5
    and !$lfl) { ($lfl) = grep /$lfre/, @mflines;
    CPAN->debug("lfl[$lfl]lfre[$lfre]") if $CPAN::DEBUG; $lfre =~ s/.+?\.//;
    } $lfl =~ s/\s.*//; # remove comments $lfl =~ s/\s+//g; # chomp would
    maybe be too system-specific my $lfl_abs =
    File::Spec->catfile($dist->{build_dir},$lfl); # warn
    "lfl_abs[$lfl_abs]"; if (-f $lfl_abs) { $self->{MANPAGE} =
    $self->manpage_headline($lfl_abs); } } } } my($item); for $item
    (qw/MANPAGE/) { push @m, sprintf($sprintf, $item, $self->{$item}) if
    exists $self->{$item}; } for $item (qw/CONTAINS/) { push @m,
    sprintf($sprintf, $item, join(" ",@{$self->{$item}})) if exists
    $self->{$item} && @{$self->{$item}}; } push @m, sprintf($sprintf,
    'INST_FILE', $local_file || "(not installed)"); push @m,
    sprintf($sprintf, 'INST_VERSION', $self->inst_version) if $local_file;
    join "", @m, "\n"; }

    sub manpage_headline { my($self,$local_file) = @_; my(@local_file) =
    $local_file; $local_file =~ s/\.pm(?!\n)\Z/.pod/; push @local_file,
    $local_file; my(@result,$locf); for $locf (@local_file) { next unless -f
    $locf; my $fh = FileHandle->new($locf) or
    $Carp::Frontend->mydie("Couldn't open $locf: $!"); my $inpod = 0; local
    $/ = "\n"; while (<$fh>) { $inpod = m/^=(?!head1\s+NAME\s*$)/ ? 0 :
    m/^=head1\s+NAME\s*$/ ? 1 : $inpod; next unless $inpod; next if /^=/;
    next if /^\s+$/; chomp; push @result, $_; } close $fh; last if @result;
    } join " ", @result; }

    #-> sub CPAN::Module::cpan_file ; # Note: also inherited by CPAN::Bundle
    sub cpan_file { my $self = shift; CPAN->debug(sprintf "id[%s]",
    $self->id) if $CPAN::DEBUG; unless ($self->ro) { CPAN::Index->reload; }
    my $ro = $self->ro; if ($ro && defined $ro->{CPAN_FILE}){ return
    $ro->{CPAN_FILE}; } else { my $userid = $self->userid; if ( $userid ) {
    if ($CPAN::META->exists("CPAN::Author",$userid)) { my $author =
    $CPAN::META->instance("CPAN::Author", $userid); my $fullname =
    $author->fullname; my $email = $author->email; unless (defined $fullname
    && defined $email) { return sprintf("Contact Author %s", $userid, ); }
    return "Contact Author $fullname <$email>"; } else { return "Contact
    Author $userid (Email address not available)"; } } else { return "N/A";
    } } }

    #-> sub CPAN::Module::cpan_version ; sub cpan_version { my $self =
    shift;

        my $ro = $self->ro;
        unless ($ro) {
            # Can happen with modules that are not on CPAN
            $ro = {};
        }
        $ro->{CPAN_VERSION} = 'undef'
            unless defined $ro->{CPAN_VERSION};
        $ro->{CPAN_VERSION};
    }

    #-> sub CPAN::Module::force ; sub force { my($self) = @_;
    $self->{'force_update'}++; }

    sub notest { my($self) = @_; # warn "XDEBUG: set notest for Module";
    $self->{'notest'}++; }

    #-> sub CPAN::Module::rematein ; sub rematein { my($self,$meth) = @_;
    $CPAN::Frontend->myprint(sprintf("Running %s for module %s\n", $meth,
    $self->id)); my $cpan_file = $self->cpan_file; if ($cpan_file eq "N/A"
    || $cpan_file =~ /^Contact Author/){ $CPAN::Frontend->mywarn(sprintf qq{
    The module %s isn\'t available on CPAN.

      Either the module has not yet been uploaded to CPAN, or it is
      temporary unavailable. Please contact the author to find out
      more about the status. Try 'i %s'.
    },
                                  $self->id,
                                  $self->id,
                                 );
          return;
        }
        my $pack = $CPAN::META->instance('CPAN::Distribution',$cpan_file);
        $pack->called_for($self->id);
        $pack->force($meth) if exists $self->{'force_update'};
        $pack->notest($meth) if exists $self->{'notest'};
        eval {
            $pack->$meth();
        };
        my $err = $@;
        $pack->unforce if $pack->can("unforce") && exists $self->{'force_update'};
        $pack->unnotest if $pack->can("unnotest") && exists $self->{'notest'};
        delete $self->{'force_update'};
        delete $self->{'notest'};
        if ($err) {
            die $err;
        }
    }

    #-> sub CPAN::Module::perldoc ; sub perldoc { shift->rematein('perldoc')
    } #-> sub CPAN::Module::readme ; sub readme { shift->rematein('readme')
    } #-> sub CPAN::Module::look ; sub look { shift->rematein('look') } #->
    sub CPAN::Module::cvs_import ; sub cvs_import {
    shift->rematein('cvs_import') } #-> sub CPAN::Module::get ; sub get {
    shift->rematein('get',@_) } #-> sub CPAN::Module::make ; sub make {
    shift->rematein('make') } #-> sub CPAN::Module::test ; sub test { my
    $self = shift; $self->{badtestcnt} ||= 0; $self->rematein('test',@_); }
    #-> sub CPAN::Module::uptodate ; sub uptodate { my($self) = @_;
    my($latest) = $self->cpan_version; $latest ||= 0; my($inst_file) =
    $self->inst_file; my($have) = 0; if (defined $inst_file) { $have =
    $self->inst_version; } local($^W)=0; if ($inst_file && !
    CPAN::Version->vgt($latest, $have) ) { CPAN->debug("returning uptodate.
    inst_file[$inst_file] ". "latest[$latest] have[$have]") if $CPAN::DEBUG;
    return 1; } return; } #-> sub CPAN::Module::install ; sub install {
    my($self) = @_; my($doit) = 0; if ($self->uptodate && not exists
    $self->{'force_update'} ) { $CPAN::Frontend->myprint(sprintf("%s is up
    to date (%s).\n", $self->id, $self->inst_version, )); } else { $doit =
    1; } my $ro = $self->ro; if ($ro && $ro->{stats} && $ro->{stats} eq "a")
    { $CPAN::Frontend->mywarn(qq{ \n\n\n ***WARNING*** The module
    $self->{ID} has no active maintainer.\n\n\n }); sleep 5; }
    $self->rematein('install') if $doit; } #-> sub CPAN::Module::clean ; sub
    clean { shift->rematein('clean') }

    #-> sub CPAN::Module::inst_file ; sub inst_file { my($self) = @_;
    my($dir,@packpath); @packpath = split /::/, $self->{ID}; $packpath[-1]
    .= ".pm"; foreach $dir (@INC) { my $pmfile =
    File::Spec->catfile($dir,@packpath); if (-f $pmfile){ return $pmfile; }
    } return; }

    #-> sub CPAN::Module::xs_file ; sub xs_file { my($self) = @_;
    my($dir,@packpath); @packpath = split /::/, $self->{ID}; push @packpath,
    $packpath[-1]; $packpath[-1] .= "." . $Config::Config{'dlext'}; foreach
    $dir (@INC) { my $xsfile = File::Spec->catfile($dir,'auto',@packpath);
    if (-f $xsfile){ return $xsfile; } } return; }

    #-> sub CPAN::Module::inst_version ; sub inst_version { my($self) = @_;
    my $parsefile = $self->inst_file or return; local($^W) = 0 if $] <
    5.00303 && $ExtUtils::MakeMaker::VERSION < 5.38; my $have;

        # there was a bug in 5.6.0 that let lots of unini warnings out of
        # parse_version. Fixed shortly after 5.6.0 by PMQS. We can remove
        # the following workaround after 5.6.1 is out.
        local($SIG{__WARN__}) =  sub { my $w = shift;
                                       return if $w =~ /uninitialized/i;
                                       warn $w;
                                     };

        $have = MM->parse_version($parsefile) || "undef";
        $have =~ s/^ //; # since the %vd hack these two lines here are needed
        $have =~ s/ $//; # trailing whitespace happens all the time

        # My thoughts about why %vd processing should happen here

        # Alt1 maintain it as string with leading v:
        # read index files     do nothing
        # compare it           use utility for compare
        # print it             do nothing

        # Alt2 maintain it as what it is
        # read index files     convert
        # compare it           use utility because there's still a ">" vs "gt" issue
        # print it             use CPAN::Version for print

        # Seems cleaner to hold it in memory as a string starting with a "v"

        # If the author of this module made a mistake and wrote a quoted
        # "v1.13" instead of v1.13, we simply leave it at that with the
        # effect that *we* will treat it like a v-tring while the rest of
        # perl won't. Seems sensible when we consider that any action we
        # could take now would just add complexity.

        $have = CPAN::Version->readable($have);

        $have =~ s/\s*//g; # stringify to float around floating point issues
        $have; # no stringify needed, \s* above matches always
    }

    package CPAN; use strict;

    1;

    __END__

NAME
    CPAN - query, download and build perl modules from CPAN sites

SYNOPSIS
    Interactive mode:

      perl -MCPAN -e shell;

    Batch mode:

      use CPAN;

      # modules:

      $mod = "Acme::Meta";
      install $mod;
      CPAN::Shell->install($mod);                    # same thing
      CPAN::Shell->expandany($mod)->install;         # same thing
      CPAN::Shell->expand("Module",$mod)->install;   # same thing
      CPAN::Shell->expand("Module",$mod)
        ->distribution->install;                     # same thing

      # distributions:

      $distro = "NWCLARK/Acme-Meta-0.01.tar.gz";
      install $distro;                                # same thing
      CPAN::Shell->install($distro);                  # same thing
      CPAN::Shell->expandany($distro)->install;       # same thing
      CPAN::Shell->expand("Module",$distro)->install; # same thing

STATUS
    This module will eventually be replaced by CPANPLUS. CPANPLUS is kind of
    a modern rewrite from ground up with greater extensibility and more
    features but no full compatibility. If you're new to CPAN.pm, you
    probably should investigate if CPANPLUS is the better choice for you. If
    you're already used to CPAN.pm you're welcome to continue using it, if
    you accept that its development is mostly (though not completely)
    stalled.

DESCRIPTION
    The CPAN module is designed to automate the make and install of perl
    modules and extensions. It includes some primitive searching
    capabilities and knows how to use Net::FTP or LWP (or some external
    download clients) to fetch the raw data from the net.

    Modules are fetched from one or more of the mirrored CPAN (Comprehensive
    Perl Archive Network) sites and unpacked in a dedicated directory.

    The CPAN module also supports the concept of named and versioned
    *bundles* of modules. Bundles simplify the handling of sets of related
    modules. See Bundles below.

    The package contains a session manager and a cache manager. There is no
    status retained between sessions. The session manager keeps track of
    what has been fetched, built and installed in the current session. The
    cache manager keeps track of the disk space occupied by the make
    processes and deletes excess space according to a simple FIFO mechanism.

    All methods provided are accessible in a programmer style and in an
    interactive shell style.

  Interactive Mode
    The interactive mode is entered by running

        perl -MCPAN -e shell

    which puts you into a readline interface. You will have the most fun if
    you install Term::ReadKey and Term::ReadLine to enjoy both history and
    command completion.

    Once you are on the command line, type 'h' and the rest should be
    self-explanatory.

    The function call "shell" takes two optional arguments, one is the
    prompt, the second is the default initial command line (the latter only
    works if a real ReadLine interface module is installed).

    The most common uses of the interactive modes are

    Searching for authors, bundles, distribution files and modules
      There are corresponding one-letter commands "a", "b", "d", and "m" for
      each of the four categories and another, "i" for any of the mentioned
      four. Each of the four entities is implemented as a class with
      slightly differing methods for displaying an object.

      Arguments you pass to these commands are either strings exactly
      matching the identification string of an object or regular expressions
      that are then matched case-insensitively against various attributes of
      the objects. The parser recognizes a regular expression only if you
      enclose it between two slashes.

      The principle is that the number of found objects influences how an
      item is displayed. If the search finds one item, the result is
      displayed with the rather verbose method "as_string", but if we find
      more than one, we display each object with the terse method
      "as_glimpse".

    make, test, install, clean modules or distributions
      These commands take any number of arguments and investigate what is
      necessary to perform the action. If the argument is a distribution
      file name (recognized by embedded slashes), it is processed. If it is
      a module, CPAN determines the distribution file in which this module
      is included and processes that, following any dependencies named in
      the module's META.yml or Makefile.PL (this behavior is controlled by
      the configuration parameter "prerequisites_policy".)

      Any "make" or "test" are run unconditionally. An

        install <distribution_file>

      also is run unconditionally. But for

        install <module>

      CPAN checks if an install is actually needed for it and prints *module
      up to date* in the case that the distribution file containing the
      module doesn't need to be updated.

      CPAN also keeps track of what it has done within the current session
      and doesn't try to build a package a second time regardless if it
      succeeded or not. The "force" pragma may precede another command
      (currently: "make", "test", or "install") and executes the command
      from scratch and tries to continue in case of some errors.

      Example:

          cpan> install OpenGL
          OpenGL is up to date.
          cpan> force install OpenGL
          Running make
          OpenGL-0.4/
          OpenGL-0.4/COPYRIGHT
          [...]

      The "notest" pragma may be set to skip the test part in the build
      process.

      Example:

          cpan> notest install Tk

      A "clean" command results in a

        make clean

      being executed within the distribution file's working directory.

    get, readme, perldoc, look module or distribution
      "get" downloads a distribution file without further action. "readme"
      displays the README file of the associated distribution. "Look" gets
      and untars (if not yet done) the distribution file, changes to the
      appropriate directory and opens a subshell process in that directory.
      "perldoc" displays the pod documentation of the module in html or
      plain text format.

    ls author
    ls globbing_expresion
      The first form lists all distribution files in and below an author's
      CPAN directory as they are stored in the CHECKUMS files distrbute on
      CPAN.

      The second form allows to limit or expand the output with shell
      globbing as in the following examples:

                ls JV/make*
                ls GSAR/*make*
                ls */*make*

      The last example is very slow and outputs extra progress indicators
      that break the alignment of the result.

    failed
      The "failed" command reports all distributions that failed on one of
      "make", "test" or "install" for some reason in the currently running
      shell session.

    Lockfile
      Interactive sessions maintain a lockfile, per default "~/.cpan/.lock"
      (but the directory can be configured via the "cpan_home" config
      variable). The shell is a bit picky if you try to start another CPAN
      session. It dies immediately if there is a lockfile and the lock seems
      to belong to a running process. In case you want to run a second shell
      session, it is probably safest to maintain another directory, say
      "~/.cpan-for-X/" and a "~/.cpan-for-X/CPAN/MyConfig.pm" that contains
      the configuration options. Then you can start the second shell with

        perl -I ~/.cpan-for-X -MCPAN::MyConfig -MCPAN -e shell

    Signals
      CPAN.pm installs signal handlers for SIGINT and SIGTERM. While you are
      in the cpan-shell it is intended that you can press "^C" anytime and
      return to the cpan-shell prompt. A SIGTERM will cause the cpan-shell
      to clean up and leave the shell loop. You can emulate the effect of a
      SIGTERM by sending two consecutive SIGINTs, which usually means by
      pressing "^C" twice.

      CPAN.pm ignores a SIGPIPE. If the user sets inactivity_timeout, a
      SIGALRM is used during the run of the "perl Makefile.PL" or "perl
      Build.PL" subprocess.

  CPAN::Shell
    The commands that are available in the shell interface are methods in
    the package CPAN::Shell. If you enter the shell command, all your input
    is split by the Text::ParseWords::shellwords() routine which acts like
    most shells do. The first word is being interpreted as the method to be
    called and the rest of the words are treated as arguments to this
    method. Continuation lines are supported if a line ends with a literal
    backslash.

  autobundle
    "autobundle" writes a bundle file into the
    "$CPAN::Config->{cpan_home}/Bundle" directory. The file contains a list
    of all modules that are both available from CPAN and currently installed
    within @INC. The name of the bundle file is based on the current date
    and a counter.

  recompile
    recompile() is a very special command in that it takes no argument and
    runs the make/test/install cycle with brute force over all installed
    dynamically loadable extensions (aka XS modules) with 'force' in effect.
    The primary purpose of this command is to finish a network installation.
    Imagine, you have a common source tree for two different architectures.
    You decide to do a completely independent fresh installation. You start
    on one architecture with the help of a Bundle file produced earlier.
    CPAN installs the whole Bundle for you, but when you try to repeat the
    job on the second architecture, CPAN responds with a "Foo up to date"
    message for all modules. So you invoke CPAN's recompile on the second
    architecture and you're done.

    Another popular use for "recompile" is to act as a rescue in case your
    perl breaks binary compatibility. If one of the modules that CPAN uses
    is in turn depending on binary compatibility (so you cannot run CPAN
    commands), then you should try the CPAN::Nox module for recovery.

  The four "CPAN::*" Classes: Author, Bundle, Module, Distribution
    Although it may be considered internal, the class hierarchy does matter
    for both users and programmer. CPAN.pm deals with above mentioned four
    classes, and all those classes share a set of methods. A classical
    single polymorphism is in effect. A metaclass object registers all
    objects of all kinds and indexes them with a string. The strings
    referencing objects have a separated namespace (well, not completely
    separated):

             Namespace                         Class

       words containing a "/" (slash)      Distribution
        words starting with Bundle::          Bundle
              everything else            Module or Author

    Modules know their associated Distribution objects. They always refer to
    the most recent official release. Developers may mark their releases as
    unstable development versions (by inserting an underbar into the module
    version number which will also be reflected in the distribution name
    when you run 'make dist'), so the really hottest and newest distribution
    is not always the default. If a module Foo circulates on CPAN in both
    version 1.23 and 1.23_90, CPAN.pm offers a convenient way to install
    version 1.23 by saying

        install Foo

    This would install the complete distribution file (say
    BAR/Foo-1.23.tar.gz) with all accompanying material. But if you would
    like to install version 1.23_90, you need to know where the distribution
    file resides on CPAN relative to the authors/id/ directory. If the
    author is BAR, this might be BAR/Foo-1.23_90.tar.gz; so you would have
    to say

        install BAR/Foo-1.23_90.tar.gz

    The first example will be driven by an object of the class CPAN::Module,
    the second by an object of class CPAN::Distribution.

  Programmer's interface
    If you do not enter the shell, the available shell commands are both
    available as methods ("CPAN::Shell->install(...)") and as functions in
    the calling package ("install(...)").

    There's currently only one class that has a stable interface -
    CPAN::Shell. All commands that are available in the CPAN shell are
    methods of the class CPAN::Shell. Each of the commands that produce
    listings of modules ("r", "autobundle", "u") also return a list of the
    IDs of all modules within the list.

    expand($type,@things)
      The IDs of all objects available within a program are strings that can
      be expanded to the corresponding real objects with the
      "CPAN::Shell->expand("Module",@things)" method. Expand returns a list
      of CPAN::Module objects according to the @things arguments given. In
      scalar context it only returns the first element of the list.

    expandany(@things)
      Like expand, but returns objects of the appropriate type, i.e.
      CPAN::Bundle objects for bundles, CPAN::Module objects for modules and
      CPAN::Distribution objects fro distributions.

    Programming Examples
      This enables the programmer to do operations that combine
      functionalities that are available in the shell.

          # install everything that is outdated on my disk:
          perl -MCPAN -e 'CPAN::Shell->install(CPAN::Shell->r)'

          # install my favorite programs if necessary:
          for $mod (qw(Net::FTP Digest::SHA Data::Dumper)){
              my $obj = CPAN::Shell->expand('Module',$mod);
              $obj->install;
          }

          # list all modules on my disk that have no VERSION number
          for $mod (CPAN::Shell->expand("Module","/./")){
              next unless $mod->inst_file;
              # MakeMaker convention for undefined $VERSION:
              next unless $mod->inst_version eq "undef";
              print "No VERSION in ", $mod->id, "\n";
          }

          # find out which distribution on CPAN contains a module:
          print CPAN::Shell->expand("Module","Apache::Constants")->cpan_file

      Or if you want to write a cronjob to watch The CPAN, you could list
      all modules that need updating. First a quick and dirty way:

          perl -e 'use CPAN; CPAN::Shell->r;'

      If you don't want to get any output in the case that all modules are
      up to date, you can parse the output of above command for the regular
      expression //modules are up to date// and decide to mail the output
      only if it doesn't match. Ick?

      If you prefer to do it more in a programmer style in one single
      process, maybe something like this suits you better:

        # list all modules on my disk that have newer versions on CPAN
        for $mod (CPAN::Shell->expand("Module","/./")){
          next unless $mod->inst_file;
          next if $mod->uptodate;
          printf "Module %s is installed as %s, could be updated to %s from CPAN\n",
              $mod->id, $mod->inst_version, $mod->cpan_version;
        }

      If that gives you too much output every day, you maybe only want to
      watch for three modules. You can write

        for $mod (CPAN::Shell->expand("Module","/Apache|LWP|CGI/")){

      as the first line instead. Or you can combine some of the above
      tricks:

        # watch only for a new mod_perl module
        $mod = CPAN::Shell->expand("Module","mod_perl");
        exit if $mod->uptodate;
        # new mod_perl arrived, let me know all update recommendations
        CPAN::Shell->r;

  Methods in the other Classes
    The programming interface for the classes CPAN::Module,
    CPAN::Distribution, CPAN::Bundle, and CPAN::Author is still considered
    beta and partially even alpha. In the following paragraphs only those
    methods are documented that have proven useful over a longer time and
    thus are unlikely to change.

    CPAN::Author::as_glimpse()
        Returns a one-line description of the author

    CPAN::Author::as_string()
        Returns a multi-line description of the author

    CPAN::Author::email()
        Returns the author's email address

    CPAN::Author::fullname()
        Returns the author's name

    CPAN::Author::name()
        An alias for fullname

    CPAN::Bundle::as_glimpse()
        Returns a one-line description of the bundle

    CPAN::Bundle::as_string()
        Returns a multi-line description of the bundle

    CPAN::Bundle::clean()
        Recursively runs the "clean" method on all items contained in the
        bundle.

    CPAN::Bundle::contains()
        Returns a list of objects' IDs contained in a bundle. The associated
        objects may be bundles, modules or distributions.

    CPAN::Bundle::force($method,@args)
        Forces CPAN to perform a task that normally would have failed. Force
        takes as arguments a method name to be called and any number of
        additional arguments that should be passed to the called method. The
        internals of the object get the needed changes so that CPAN.pm does
        not refuse to take the action. The "force" is passed recursively to
        all contained objects.

    CPAN::Bundle::get()
        Recursively runs the "get" method on all items contained in the
        bundle

    CPAN::Bundle::inst_file()
        Returns the highest installed version of the bundle in either @INC
        or "$CPAN::Config-"{cpan_home}>. Note that this is different from
        CPAN::Module::inst_file.

    CPAN::Bundle::inst_version()
        Like CPAN::Bundle::inst_file, but returns the $VERSION

    CPAN::Bundle::uptodate()
        Returns 1 if the bundle itself and all its members are uptodate.

    CPAN::Bundle::install()
        Recursively runs the "install" method on all items contained in the
        bundle

    CPAN::Bundle::make()
        Recursively runs the "make" method on all items contained in the
        bundle

    CPAN::Bundle::readme()
        Recursively runs the "readme" method on all items contained in the
        bundle

    CPAN::Bundle::test()
        Recursively runs the "test" method on all items contained in the
        bundle

    CPAN::Distribution::as_glimpse()
        Returns a one-line description of the distribution

    CPAN::Distribution::as_string()
        Returns a multi-line description of the distribution

    CPAN::Distribution::clean()
        Changes to the directory where the distribution has been unpacked
        and runs "make clean" there.

    CPAN::Distribution::containsmods()
        Returns a list of IDs of modules contained in a distribution file.
        Only works for distributions listed in the 02packages.details.txt.gz
        file. This typically means that only the most recent version of a
        distribution is covered.

    CPAN::Distribution::cvs_import()
        Changes to the directory where the distribution has been unpacked
        and runs something like

            cvs -d $cvs_root import -m $cvs_log $cvs_dir $userid v$version

        there.

    CPAN::Distribution::dir()
        Returns the directory into which this distribution has been
        unpacked.

    CPAN::Distribution::force($method,@args)
        Forces CPAN to perform a task that normally would have failed. Force
        takes as arguments a method name to be called and any number of
        additional arguments that should be passed to the called method. The
        internals of the object get the needed changes so that CPAN.pm does
        not refuse to take the action.

    CPAN::Distribution::get()
        Downloads the distribution from CPAN and unpacks it. Does nothing if
        the distribution has already been downloaded and unpacked within the
        current session.

    CPAN::Distribution::install()
        Changes to the directory where the distribution has been unpacked
        and runs the external command "make install" there. If "make" has
        not yet been run, it will be run first. A "make test" will be issued
        in any case and if this fails, the install will be canceled. The
        cancellation can be avoided by letting "force" run the "install" for
        you.

    CPAN::Distribution::isa_perl()
        Returns 1 if this distribution file seems to be a perl distribution.
        Normally this is derived from the file name only, but the index from
        CPAN can contain a hint to achieve a return value of true for other
        filenames too.

    CPAN::Distribution::look()
        Changes to the directory where the distribution has been unpacked
        and opens a subshell there. Exiting the subshell returns.

    CPAN::Distribution::make()
        First runs the "get" method to make sure the distribution is
        downloaded and unpacked. Changes to the directory where the
        distribution has been unpacked and runs the external commands "perl
        Makefile.PL" or "perl Build.PL" and "make" there.

    CPAN::Distribution::prereq_pm()
        Returns the hash reference that has been announced by a distribution
        as the "requires" element of the META.yml or the "PREREQ_PM" hash in
        the "Makefile.PL". Note: works only after an attempt has been made
        to "make" the distribution. Returns undef otherwise.

    CPAN::Distribution::readme()
        Downloads the README file associated with a distribution and runs it
        through the pager specified in "$CPAN::Config-"{pager}>.

    CPAN::Distribution::perldoc()
        Downloads the pod documentation of the file associated with a
        distribution (in html format) and runs it through the external
        command lynx specified in "$CPAN::Config-"{lynx}>. If lynx isn't
        available, it converts it to plain text with external command
        html2text and runs it through the pager specified in
        "$CPAN::Config-"{pager}>

    CPAN::Distribution::test()
        Changes to the directory where the distribution has been unpacked
        and runs "make test" there.

    CPAN::Distribution::uptodate()
        Returns 1 if all the modules contained in the distribution are
        uptodate. Relies on containsmods.

    CPAN::Index::force_reload()
        Forces a reload of all indices.

    CPAN::Index::reload()
        Reloads all indices if they have not been read for more than
        "$CPAN::Config-"{index_expire}> days.

    CPAN::InfoObj::dump()
        CPAN::Author, CPAN::Bundle, CPAN::Module, and CPAN::Distribution
        inherit this method. It prints the data structure associated with an
        object. Useful for debugging. Note: the data structure is considered
        internal and thus subject to change without notice.

    CPAN::Module::as_glimpse()
        Returns a one-line description of the module

    CPAN::Module::as_string()
        Returns a multi-line description of the module

    CPAN::Module::clean()
        Runs a clean on the distribution associated with this module.

    CPAN::Module::cpan_file()
        Returns the filename on CPAN that is associated with the module.

    CPAN::Module::cpan_version()
        Returns the latest version of this module available on CPAN.

    CPAN::Module::cvs_import()
        Runs a cvs_import on the distribution associated with this module.

    CPAN::Module::description()
        Returns a 44 character description of this module. Only available
        for modules listed in The Module List
        (CPAN/modules/00modlist.long.html or 00modlist.long.txt.gz)

    CPAN::Module::force($method,@args)
        Forces CPAN to perform a task that normally would have failed. Force
        takes as arguments a method name to be called and any number of
        additional arguments that should be passed to the called method. The
        internals of the object get the needed changes so that CPAN.pm does
        not refuse to take the action.

    CPAN::Module::get()
        Runs a get on the distribution associated with this module.

    CPAN::Module::inst_file()
        Returns the filename of the module found in @INC. The first file
        found is reported just like perl itself stops searching @INC when it
        finds a module.

    CPAN::Module::inst_version()
        Returns the version number of the module in readable format.

    CPAN::Module::install()
        Runs an "install" on the distribution associated with this module.

    CPAN::Module::look()
        Changes to the directory where the distribution associated with this
        module has been unpacked and opens a subshell there. Exiting the
        subshell returns.

    CPAN::Module::make()
        Runs a "make" on the distribution associated with this module.

    CPAN::Module::manpage_headline()
        If module is installed, peeks into the module's manpage, reads the
        headline and returns it. Moreover, if the module has been downloaded
        within this session, does the equivalent on the downloaded module
        even if it is not installed.

    CPAN::Module::readme()
        Runs a "readme" on the distribution associated with this module.

    CPAN::Module::perldoc()
        Runs a "perldoc" on this module.

    CPAN::Module::test()
        Runs a "test" on the distribution associated with this module.

    CPAN::Module::uptodate()
        Returns 1 if the module is installed and up-to-date.

    CPAN::Module::userid()
        Returns the author's ID of the module.

  Cache Manager
    Currently the cache manager only keeps track of the build directory
    ($CPAN::Config->{build_dir}). It is a simple FIFO mechanism that deletes
    complete directories below "build_dir" as soon as the size of all
    directories there gets bigger than $CPAN::Config->{build_cache} (in MB).
    The contents of this cache may be used for later re-installations that
    you intend to do manually, but will never be trusted by CPAN itself.
    This is due to the fact that the user might use these directories for
    building modules on different architectures.

    There is another directory ($CPAN::Config->{keep_source_where}) where
    the original distribution files are kept. This directory is not covered
    by the cache manager and must be controlled by the user. If you choose
    to have the same directory as build_dir and as keep_source_where
    directory, then your sources will be deleted with the same fifo
    mechanism.

  Bundles
    A bundle is just a perl module in the namespace Bundle:: that does not
    define any functions or methods. It usually only contains documentation.

    It starts like a perl module with a package declaration and a $VERSION
    variable. After that the pod section looks like any other pod with the
    only difference being that *one special pod section* exists starting
    with (verbatim):

            =head1 CONTENTS

    In this pod section each line obeys the format

            Module_Name [Version_String] [- optional text]

    The only required part is the first field, the name of a module (e.g.
    Foo::Bar, ie. *not* the name of the distribution file). The rest of the
    line is optional. The comment part is delimited by a dash just as in the
    man page header.

    The distribution of a bundle should follow the same convention as other
    distributions.

    Bundles are treated specially in the CPAN package. If you say 'install
    Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all
    the modules in the CONTENTS section of the pod. You can install your own
    Bundles locally by placing a conformant Bundle file somewhere into your
    @INC path. The autobundle() command which is available in the shell
    interface does that for you by including all currently installed modules
    in a snapshot bundle file.

  Prerequisites
    If you have a local mirror of CPAN and can access all files with "file:"
    URLs, then you only need a perl better than perl5.003 to run this
    module. Otherwise Net::FTP is strongly recommended. LWP may be required
    for non-UNIX systems or if your nearest CPAN site is associated with a
    URL that is not "ftp:".

    If you have neither Net::FTP nor LWP, there is a fallback mechanism
    implemented for an external ftp command or for an external lynx command.

  Finding packages and VERSION
    This module presumes that all packages on CPAN

    * declare their $VERSION variable in an easy to parse manner. This
      prerequisite can hardly be relaxed because it consumes far too much
      memory to load all packages into the running program just to determine
      the $VERSION variable. Currently all programs that are dealing with
      version use something like this

          perl -MExtUtils::MakeMaker -le \
              'print MM->parse_version(shift)' filename

      If you are author of a package and wonder if your $VERSION can be
      parsed, please try the above method.

    * come as compressed or gzipped tarfiles or as zip files and contain a
      "Makefile.PL" or "Build.PL" (well, we try to handle a bit more, but
      without much enthusiasm).

  Debugging
    The debugging of this module is a bit complex, because we have
    interferences of the software producing the indices on CPAN, of the
    mirroring process on CPAN, of packaging, of configuration, of
    synchronicity, and of bugs within CPAN.pm.

    For code debugging in interactive mode you can try "o debug" which will
    list options for debugging the various parts of the code. You should
    know that "o debug" has built-in completion support.

    For data debugging there is the "dump" command which takes the same
    arguments as make/test/install and outputs the object's Data::Dumper
    dump.

  Floppy, Zip, Offline Mode
    CPAN.pm works nicely without network too. If you maintain machines that
    are not networked at all, you should consider working with file: URLs.
    Of course, you have to collect your modules somewhere first. So you
    might use CPAN.pm to put together all you need on a networked machine.
    Then copy the $CPAN::Config->{keep_source_where} (but not
    $CPAN::Config->{build_dir}) directory on a floppy. This floppy is kind
    of a personal CPAN. CPAN.pm on the non-networked machines works nicely
    with this floppy. See also below the paragraph about CD-ROM support.

CONFIGURATION
    When the CPAN module is used for the first time, a configuration dialog
    tries to determine a couple of site specific options. The result of the
    dialog is stored in a hash reference $CPAN::Config in a file
    CPAN/Config.pm.

    The default values defined in the CPAN/Config.pm file can be overridden
    in a user specific file: CPAN/MyConfig.pm. Such a file is best placed in
    $HOME/.cpan/CPAN/MyConfig.pm, because $HOME/.cpan is added to the search
    path of the CPAN module before the use() or require() statements.

    The configuration dialog can be started any time later again by issuing
    the command " o conf init " in the CPAN shell.

    Currently the following keys in the hash reference $CPAN::Config are
    defined:

      build_cache        size of cache for directories to build modules
      build_dir          locally accessible directory to build modules
      index_expire       after this many days refetch index files
      cache_metadata     use serializer to cache metadata
      cpan_home          local directory reserved for this package
      dontload_hash      anonymous hash: modules in the keys will not be
                         loaded by the CPAN::has_inst() routine
      gzip               location of external program gzip
      histfile           file to maintain history between sessions
      histsize           maximum number of lines to keep in histfile
      inactivity_timeout breaks interactive Makefile.PLs or Build.PLs
                         after this many seconds inactivity. Set to 0 to
                         never break.
      inhibit_startup_message
                         if true, does not print the startup message
      keep_source_where  directory in which to keep the source (if we do)
      make               location of external make program
      make_arg           arguments that should always be passed to 'make'
      make_install_make_command
                         the make command for running 'make install', for
                         example 'sudo make'
      make_install_arg   same as make_arg for 'make install'
      makepl_arg         arguments passed to 'perl Makefile.PL'
      mbuild_arg         arguments passed to './Build'
      mbuild_install_arg arguments passed to './Build install'
      mbuild_install_build_command
                         command to use instead of './Build' when we are
                         in the install stage, for example 'sudo ./Build'
      mbuildpl_arg       arguments passed to 'perl Build.PL'
      pager              location of external program more (or any pager)
      prefer_installer   legal values are MB and EUMM: if a module
                         comes with both a Makefile.PL and a Build.PL, use
                         the former (EUMM) or the latter (MB)
      prerequisites_policy
                         what to do if you are missing module prerequisites
                         ('follow' automatically, 'ask' me, or 'ignore')
      proxy_user         username for accessing an authenticating proxy
      proxy_pass         password for accessing an authenticating proxy
      scan_cache         controls scanning of cache ('atstart' or 'never')
      tar                location of external program tar
      term_is_latin      if true internal UTF-8 is translated to ISO-8859-1
                         (and nonsense for characters outside latin range)
      unzip              location of external program unzip
      urllist            arrayref to nearby CPAN sites (or equivalent locations)
      wait_list          arrayref to a wait server to try (See CPAN::WAIT)
      ftp_proxy,      }  the three usual variables for configuring
        http_proxy,   }  proxy requests. Both as CPAN::Config variables
        no_proxy      }  and as environment variables configurable.

    You can set and query each of these options interactively in the cpan
    shell with the command set defined within the "o conf" command:

    "o conf <scalar option>"
      prints the current value of the *scalar option*

    "o conf <scalar option> <value>"
      Sets the value of the *scalar option* to *value*

    "o conf <list option>"
      prints the current value of the *list option* in MakeMaker's neatvalue
      format.

    "o conf <list option> [shift|pop]"
      shifts or pops the array in the *list option* variable

    "o conf <list option> [unshift|push|splice] <list>"
      works like the corresponding perl commands.

  Note on urllist parameter's format
    urllist parameters are URLs according to RFC 1738. We do a little
    guessing if your URL is not compliant, but if you have problems with
    file URLs, please try the correct format. Either:

        file://localhost/whatever/ftp/pub/CPAN/

    or

        file:///home/ftp/pub/CPAN/

  urllist parameter has CD-ROM support
    The "urllist" parameter of the configuration table contains a list of
    URLs that are to be used for downloading. If the list contains any
    "file" URLs, CPAN always tries to get files from there first. This
    feature is disabled for index files. So the recommendation for the owner
    of a CD-ROM with CPAN contents is: include your local, possibly outdated
    CD-ROM as a "file" URL at the end of urllist, e.g.

      o conf urllist push file://localhost/CDROM/CPAN

    CPAN.pm will then fetch the index files from one of the CPAN sites that
    come at the beginning of urllist. It will later check for each module if
    there is a local copy of the most recent version.

    Another peculiarity of urllist is that the site that we could
    successfully fetch the last file from automatically gets a preference
    token and is tried as the first site for the next request. So if you add
    a new site at runtime it may happen that the previously preferred site
    will be tried another time. This means that if you want to disallow a
    site for the next transfer, it must be explicitly removed from urllist.

SECURITY
    There's no strong security layer in CPAN.pm. CPAN.pm helps you to
    install foreign, unmasked, unsigned code on your machine. We compare to
    a checksum that comes from the net just as the distribution file itself.
    But we try to make it easy to add security on demand:

  Cryptographically signed modules
    Since release 1.77 CPAN.pm has been able to verify cryptographically
    signed module distributions using Module::Signature. The CPAN modules
    can be signed by their authors, thus giving more security. The simple
    unsigned MD5 checksums that were used before by CPAN protect mainly
    against accidental file corruption.

    You will need to have Module::Signature installed, which in turn
    requires that you have at least one of Crypt::OpenPGP module or the
    command-line gpg tool installed.

    You will also need to be able to connect over the Internet to the public
    keyservers, like pgp.mit.edu, and their port 11731 (the HKP protocol).

EXPORT
    Most functions in package CPAN are exported per default. The reason for
    this is that the primary use is intended for the cpan shell or for
    one-liners.

ENVIRONMENT
    When the CPAN shell enters a subshell via the look command, it sets the
    environment CPAN_SHELL_LEVEL to 1 or increments it if it is already set.

POPULATE AN INSTALLATION WITH LOTS OF MODULES
    Populating a freshly installed perl with my favorite modules is pretty
    easy if you maintain a private bundle definition file. To get a useful
    blueprint of a bundle definition file, the command autobundle can be
    used on the CPAN shell command line. This command writes a bundle
    definition file for all modules that are installed for the currently
    running perl interpreter. It's recommended to run this command only once
    and from then on maintain the file manually under a private name, say
    Bundle/my_bundle.pm. With a clever bundle file you can then simply say

        cpan> install Bundle::my_bundle

    then answer a few questions and then go out for a coffee.

    Maintaining a bundle definition file means keeping track of two things:
    dependencies and interactivity. CPAN.pm sometimes fails on calculating
    dependencies because not all modules define all MakeMaker attributes
    correctly, so a bundle definition file should specify prerequisites as
    early as possible. On the other hand, it's a bit annoying that many
    distributions need some interactive configuring. So what I try to
    accomplish in my private bundle file is to have the packages that need
    to be configured early in the file and the gentle ones later, so I can
    go out after a few minutes and leave CPAN.pm untended.

WORKING WITH CPAN.pm BEHIND FIREWALLS
    Thanks to Graham Barr for contributing the following paragraphs about
    the interaction between perl, and various firewall configurations. For
    further information on firewalls, it is recommended to consult the
    documentation that comes with the ncftp program. If you are unable to go
    through the firewall with a simple Perl setup, it is very likely that
    you can configure ncftp so that it works for your firewall.

  Three basic types of firewalls
    Firewalls can be categorized into three basic types.

    http firewall
        This is where the firewall machine runs a web server and to access
        the outside world you must do it via the web server. If you set
        environment variables like http_proxy or ftp_proxy to a values
        beginning with http:// or in your web browser you have to set proxy
        information then you know you are running an http firewall.

        To access servers outside these types of firewalls with perl (even
        for ftp) you will need to use LWP.

    ftp firewall
        This where the firewall machine runs an ftp server. This kind of
        firewall will only let you access ftp servers outside the firewall.
        This is usually done by connecting to the firewall with ftp, then
        entering a username like "user@outside.host.com"

        To access servers outside these type of firewalls with perl you will
        need to use Net::FTP.

    One way visibility
        I say one way visibility as these firewalls try to make themselves
        look invisible to the users inside the firewall. An FTP data
        connection is normally created by sending the remote server your IP
        address and then listening for the connection. But the remote server
        will not be able to connect to you because of the firewall. So for
        these types of firewall FTP connections need to be done in a passive
        mode.

        There are two that I can think off.

        SOCKS
            If you are using a SOCKS firewall you will need to compile perl
            and link it with the SOCKS library, this is what is normally
            called a 'socksified' perl. With this executable you will be
            able to connect to servers outside the firewall as if it is not
            there.

        IP Masquerade
            This is the firewall implemented in the Linux kernel, it allows
            you to hide a complete network behind one IP address. With this
            firewall no special compiling is needed as you can access hosts
            directly.

            For accessing ftp servers behind such firewalls you may need to
            set the environment variable "FTP_PASSIVE" to a true value, e.g.

                env FTP_PASSIVE=1 perl -MCPAN -eshell

            or

                perl -MCPAN -e '$ENV{FTP_PASSIVE} = 1; shell'

  Configuring lynx or ncftp for going through a firewall
    If you can go through your firewall with e.g. lynx, presumably with a
    command such as

        /usr/local/bin/lynx -pscott:tiger

    then you would configure CPAN.pm with the command

        o conf lynx "/usr/local/bin/lynx -pscott:tiger"

    That's all. Similarly for ncftp or ftp, you would configure something
    like

        o conf ncftp "/usr/bin/ncftp -f /home/scott/ncftplogin.cfg"

    Your mileage may vary...

FAQ
    1)  I installed a new version of module X but CPAN keeps saying, I have
        the old version installed

        Most probably you do have the old version installed. This can happen
        if a module installs itself into a different directory in the @INC
        path than it was previously installed. This is not really a CPAN.pm
        problem, you would have the same problem when installing the module
        manually. The easiest way to prevent this behaviour is to add the
        argument "UNINST=1" to the "make install" call, and that is why many
        people add this argument permanently by configuring

          o conf make_install_arg UNINST=1

    2)  So why is UNINST=1 not the default?

        Because there are people who have their precise expectations about
        who may install where in the @INC path and who uses which @INC
        array. In fine tuned environments "UNINST=1" can cause damage.

    3)  I want to clean up my mess, and install a new perl along with all
        modules I have. How do I go about it?

        Run the autobundle command for your old perl and optionally rename
        the resulting bundle file (e.g. Bundle/mybundle.pm), install the new
        perl with the Configure option prefix, e.g.

            ./Configure -Dprefix=/usr/local/perl-5.6.78.9

        Install the bundle file you produced in the first step with
        something like

            cpan> install Bundle::mybundle

        and you're done.

    4)  When I install bundles or multiple modules with one command there is
        too much output to keep track of.

        You may want to configure something like

          o conf make_arg "| tee -ai /root/.cpan/logs/make.out"
          o conf make_install_arg "| tee -ai /root/.cpan/logs/make_install.out"

        so that STDOUT is captured in a file for later inspection.

    5)  I am not root, how can I install a module in a personal directory?

        First of all, you will want to use your own configuration, not the
        one that your root user installed. The following command sequence is
        a possible approach:

            % mkdir -p $HOME/.cpan/CPAN
            % echo '$CPAN::Config={ };' > $HOME/.cpan/CPAN/MyConfig.pm
            % cpan
            [...answer all questions...]

        You will most probably like something like this:

          o conf makepl_arg "LIB=~/myperl/lib \
                            INSTALLMAN1DIR=~/myperl/man/man1 \
                            INSTALLMAN3DIR=~/myperl/man/man3"

        You can make this setting permanent like all "o conf" settings with
        "o conf commit".

        You will have to add ~/myperl/man to the MANPATH environment
        variable and also tell your perl programs to look into ~/myperl/lib,
        e.g. by including

          use lib "$ENV{HOME}/myperl/lib";

        or setting the PERL5LIB environment variable.

        Another thing you should bear in mind is that the UNINST parameter
        should never be set if you are not root.

    6)  How to get a package, unwrap it, and make a change before building
        it?

          look Sybase::Sybperl

    7)  I installed a Bundle and had a couple of fails. When I retried,
        everything resolved nicely. Can this be fixed to work on first try?

        The reason for this is that CPAN does not know the dependencies of
        all modules when it starts out. To decide about the additional items
        to install, it just uses data found in the generated Makefile. An
        undetected missing piece breaks the process. But it may well be that
        your Bundle installs some prerequisite later than some depending
        item and thus your second try is able to resolve everything. Please
        note, CPAN.pm does not know the dependency tree in advance and
        cannot sort the queue of things to install in a topologically
        correct order. It resolves perfectly well IFF all modules declare
        the prerequisites correctly with the PREREQ_PM attribute to
        MakeMaker. For bundles which fail and you need to install often, it
        is recommended to sort the Bundle definition file manually. It is
        planned to improve the metadata situation for dependencies on CPAN
        in general, but this will still take some time.

    8)  In our intranet we have many modules for internal use. How can I
        integrate these modules with CPAN.pm but without uploading the
        modules to CPAN?

        Have a look at the CPAN::Site module.

    9)  When I run CPAN's shell, I get error msg about line 1 to 4, setting
        meta input/output via the /etc/inputrc file.

        Some versions of readline are picky about capitalization in the
        /etc/inputrc file and specifically RedHat 6.2 comes with a
        /etc/inputrc that contains the word "on" in lowercase. Change the
        occurrences of "on" to "On" and the bug should disappear.

    10) Some authors have strange characters in their names.

        Internally CPAN.pm uses the UTF-8 charset. If your terminal is
        expecting ISO-8859-1 charset, a converter can be activated by
        setting term_is_latin to a true value in your config file. One way
        of doing so would be

            cpan> ! $CPAN::Config->{term_is_latin}=1

        Extended support for converters will be made available as soon as
        perl becomes stable with regard to charset issues.

    11) When an install fails for some reason and then I correct the error
        condition and retry, CPAN.pm refuses to install the module, saying
        "Already tried without success".

        Use the force pragma like so

          force install Foo::Bar

        This does a bit more than really needed because it untars the
        distribution again and runs make and test and only then install.

        Or, if you find this is too fast and you would prefer to do smaller
        steps, say

          force get Foo::Bar

        first and then continue as always. "Force get" *forgets* previous
        error conditions.

        Or you can use

          look Foo::Bar

        and then 'make install' directly in the subshell.

        Or you leave the CPAN shell and start it again.

        For the really curious, by accessing internals directly, you *could*

          ! delete  CPAN::Shell->expand("Distribution", \
            CPAN::Shell->expand("Module","Foo::Bar") \
            ->cpan_file)->{install}

        but this is neither guaranteed to work in the future nor is it a
        decent command.

BUGS
    If a Makefile.PL requires special customization of libraries, prompts
    the user for special input, etc. then you may find CPAN is not able to
    build the distribution. In that case it is recommended to attempt the
    traditional method of building a Perl module package from a shell, for
    example by using the 'look' command to open a subshell in the
    distribution's own directory.

AUTHOR
    Andreas Koenig "<andk@cpan.org>"

TRANSLATIONS
    Kawai,Takanori provides a Japanese translation of this manpage at
    http://member.nifty.ne.jp/hippo2000/perltips/CPAN.htm

SEE ALSO
    cpan(1), CPAN::Nox(3pm), CPAN::Version(3pm)

